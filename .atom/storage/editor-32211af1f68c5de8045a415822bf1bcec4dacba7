{"mode":"editor","version":1,"windowDimensions":{"x":583,"y":135,"width":1024,"height":1058},"syntax":{"deserializer":"Syntax","grammarOverridesByPath":{}},"project":{"path":"/Users/kwatanabe/git/whiteplus/hiroie/hiroie_api_develop/api.hiroie.jp/fuel/core/classes/controller","buffers":[{"text":"<?php\n\nnamespace Fuel\\Core;\n\nabstract class Controller_Rest extends \\Controller\n{\n\n\t/**\n\t * @var  null|string  Set this in a controller to use a default format\n\t */\n\tprotected $rest_format = null;\n\n\t/**\n\t * @var  array  contains a list of method properties such as limit, log and level\n\t */\n\tprotected $methods = array();\n\n\t/**\n\t * @var  integer  status code to return in case a not defined action is called\n\t */\n\tprotected $no_method_status = 405;\n\n\t/**\n\t * @var  integer  status code to return in case the called action doesn't return data\n\t */\n\tprotected $no_data_status = 204;\n\n\t/**\n\t * @var  string  authentication to be used for this controller\n\t */\n\tprotected $auth = null;\n\n\t/**\n\t * @var  string  the detected response format\n\t */\n\tprotected $format = null;\n\n\t/**\n\t * @var  integer  response http status\n\t */\n\tprotected $http_status = null;\n\n\t/**\n\t * @var  string  xml basenode name\n\t */\n\tprotected $xml_basenode = null;\n\n\t/**\n\t * @var  array  List all supported methods\n\t */\n\tprotected $_supported_formats = array(\n\t\t'xml' => 'application/xml',\n\t\t'rawxml' => 'application/xml',\n\t\t'json' => 'application/json',\n\t\t'jsonp'=> 'text/javascript',\n\t\t'serialized' => 'application/vnd.php.serialized',\n\t\t'php' => 'text/plain',\n\t\t'html' => 'text/html',\n\t\t'csv' => 'application/csv',\n\t);\n\n\tpublic function before()\n\t{\n\t\tparent::before();\n\n\t\t// Some Methods cant have a body\n\t\t$this->request->body = null;\n\n\t\t// Which format should the data be returned in?\n\t\t$this->request->lang = $this->_detect_lang();\n\n\t\t$this->response = \\Response::forge();\n\t}\n\n\tpublic function after($response)\n\t{\n\t\t// If the response is an array\n\t\tif (is_array($response))\n\t\t{\n\t\t\t// set the response\n\t\t\t$response = $this->response($response);\n\t\t}\n\n\t\t// If the response is a Response object, we will use their\n\t\t// instead of ours.\n\t\tif ( ! $response instanceof Response)\n\t\t{\n\t\t\t$response = $this->response;\n\t\t}\n\n\t\treturn parent::after($response);\n\t}\n\n\t/**\n\t * Router\n\t *\n\t * Requests are not made to methods directly The request will be for an \"object\".\n\t * this simply maps the object and method to the correct Controller method.\n\t *\n\t * @param  string\n\t * @param  array\n\t */\n\tpublic function router($resource, $arguments)\n\t{\n\t\t\\Config::load('rest', true);\n\n\t\t// If no (or an invalid) format is given, auto detect the format\n\t\tif (is_null($this->format) or ! array_key_exists($this->format, $this->_supported_formats))\n\t\t{\n\t\t\t// auto-detect the format\n\t\t\t$this->format = array_key_exists(\\Input::extension(), $this->_supported_formats) ? \\Input::extension() : $this->_detect_format();\n\t\t}\n\n\t\t// Get the configured auth method if none is defined\n\t\t$this->auth === null and $this->auth = \\Config::get('rest.auth');\n\n\t\t//Check method is authorized if required, and if we're authorized\n\t\tif ($this->auth == 'basic')\n\t\t{\n\t\t\t$valid_login = $this->_prepare_basic_auth();\n\t\t}\n\t\telseif ($this->auth == 'digest')\n\t\t{\n\t\t\t$valid_login = $this->_prepare_digest_auth();\n\t\t}\n\t\telseif (method_exists($this, $this->auth))\n\t\t{\n\t\t\tif (($valid_login = $this->{$this->auth}()) instanceOf \\Response)\n\t\t\t{\n\t\t\t\treturn $valid_login;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t$valid_login = false;\n\t\t}\n\n\t\t//If the request passes auth then execute as normal\n\t\tif(empty($this->auth) or $valid_login)\n\t\t{\n\t\t\t// If they call user, go to $this->post_user();\n\t\t\t$controller_method = strtolower(\\Input::method()) . '_' . $resource;\n\n\t\t\t// Fall back to action_ if no rest method is provided\n\t\t\tif ( ! method_exists($this, $controller_method))\n\t\t\t{\n\t\t\t\t$controller_method = 'action_'.$resource;\n\t\t\t}\n\n\t\t\t// If method is not available, set status code to 404\n\t\t\tif (method_exists($this, $controller_method))\n\t\t\t{\n\t\t\t\treturn call_fuel_func_array(array($this, $controller_method), $arguments);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t$this->response->status = $this->no_method_status;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t$this->response(array('status'=> 0, 'error'=> 'Not Authorized'), 401);\n\t\t}\n\t}\n\n\t/**\n\t * Response\n\t *\n\t * Takes pure data and optionally a status code, then creates the response\n\t *\n\t * @param   mixed\n\t * @param   int\n\t * @return  object  Response instance\n\t */\n\tprotected function response($data = array(), $http_status = null)\n\t{\n\t\t// set the correct response header\n\t\tif (method_exists('Format', 'to_'.$this->format))\n\t\t{\n\t\t\t$this->response->set_header('Content-Type', $this->_supported_formats[$this->format]);\n\t\t}\n\n\t\t// no data returned?\n\t\tif ((is_array($data) and empty($data)) or ($data == ''))\n\t\t{\n\t\t\t// override the http status with the NO CONTENT status\n\t\t\t$http_status = $this->no_data_status;\n\t\t}\n\n\t\t// make sure we have a valid return status\n\t\t$http_status or $http_status = $this->http_status;\n\n\t\t// If the format method exists, call and return the output in that format\n\t\tif (method_exists('Format', 'to_'.$this->format))\n\t\t{\n\t\t\t// Handle XML output\n\t\t\tif ($this->format === 'xml')\n\t\t\t{\n\t\t\t\t// Detect basenode\n\t\t\t\t$xml_basenode = $this->xml_basenode;\n\t\t\t\t$xml_basenode or $xml_basenode = \\Config::get('rest.xml_basenode', 'xml');\n\n\t\t\t\t// Set the XML response\n\t\t\t\t$this->response->body(\\Format::forge($data)->{'to_'.$this->format}(null, null, $xml_basenode));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// Set the formatted response\n\t\t\t\t$this->response->body(\\Format::forge($data)->{'to_'.$this->format}());\n\t\t\t}\n\t\t}\n\n\t\t// Format not supported, but the output is an array or an object that can not be cast to string\n\t\telseif (is_array($data) or (is_object($data) and ! method_exists($data, '__toString')))\n\t\t{\n\t\t\tif (\\Fuel::$env == \\Fuel::PRODUCTION)\n\t\t\t{\n\t\t\t\t// not acceptable in production\n\t\t\t\t$http_status = 406;\n\t\t\t\t$this->response->body('The requested REST method returned an array or object, which is not compatible with the output format \"'.$this->format.'\"');\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// convert it to json so we can at least read it while we're developing\n\t\t\t\t$this->response->body('The requested REST method returned an array or object:<br /><br />'.\\Format::forge($data)->to_json(null, true));\n\t\t\t}\n\t\t}\n\n\t\t// Format not supported, output directly\n\t\telse\n\t\t{\n\t\t\t$this->response->body($data);\n\t\t}\n\n\t\t// Set the reponse http status\n\t\t$http_status and $this->response->status = $http_status;\n\n\t\treturn $this->response;\n\t}\n\n\t/**\n\t * Set the Response http status.\n\t *\n\t * @param   integer  $status  response http status code\n\t * @return  void\n\t */\n\tprotected function http_status($status)\n\t{\n\t\t$this->http_status = $status;\n\t}\n\n\t/**\n\t * Detect format\n\t *\n\t * Detect which format should be used to output the data\n\t *\n\t * @return  string\n\t */\n\tprotected function _detect_format()\n\t{\n\t\t// A format has been passed as a named parameter in the route\n\t\tif ($this->param('format') and array_key_exists($this->param('format'), $this->_supported_formats))\n\t\t{\n\t\t\treturn $this->param('format');\n\t\t}\n\n\t\t// A format has been passed as an argument in the URL and it is supported\n\t\tif (\\Input::param('format') and array_key_exists(\\Input::param('format'), $this->_supported_formats))\n\t\t{\n\t\t\treturn \\Input::param('format');\n\t\t}\n\n\t\t// Otherwise, check the HTTP_ACCEPT (if it exists and we are allowed)\n\t\tif ($acceptable = \\Input::server('HTTP_ACCEPT') and \\Config::get('rest.ignore_http_accept') !== true)\n\t\t{\n\t\t\t// If anything is accepted, and we have a default, return that\n\t\t\tif ($acceptable == '*/*' and ! empty($this->rest_format))\n\t\t\t{\n\t\t\t\treturn $this->rest_format;\n\t\t\t}\n\n\t\t\t// Split the Accept header and build an array of quality scores for each format\n\t\t\t$fragments = new \\CachingIterator(new \\ArrayIterator(preg_split('/[,;]/', \\Input::server('HTTP_ACCEPT'))));\n\t\t\t$acceptable = array();\n\t\t\t$next_is_quality = false;\n\t\t\tforeach ($fragments as $fragment)\n\t\t\t{\n\t\t\t\t$quality = 1;\n\t\t\t\t// Skip the fragment if it is a quality score\n\t\t\t\tif ($next_is_quality)\n\t\t\t\t{\n\t\t\t\t\t$next_is_quality = false;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// If next fragment exists and is a quality score, set the quality score\n\t\t\t\telseif ($fragments->hasNext())\n\t\t\t\t{\n\t\t\t\t\t$next = $fragments->getInnerIterator()->current();\n\t\t\t\t\tif (strpos($next, 'q=') === 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tlist($key, $quality) = explode('=', $next);\n\t\t\t\t\t\t$next_is_quality = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t$acceptable[$fragment] = $quality;\n\t\t\t}\n\n\t\t\t// Sort the formats by score in descending order\n\t\t\tuasort($acceptable, function($a, $b)\n\t\t\t{\n\t\t\t\t$a = (float) $a;\n\t\t\t\t$b = (float) $b;\n\t\t\t\treturn ($a > $b) ? -1 : 1;\n\t\t\t});\n\n\t\t\t// Check each of the acceptable formats against the supported formats\n\t\t\tforeach ($acceptable as $pattern => $quality)\n\t\t\t{\n\t\t\t\t// The Accept header can contain wildcards in the format\n\t\t\t\t$find = array('*', '/');\n\t\t\t\t$replace = array('.*', '\\/');\n\t\t\t\t$pattern = '/^' . str_replace($find, $replace, $pattern) . '$/';\n\t\t\t\tforeach ($this->_supported_formats as $format => $mime)\n\t\t\t\t{\n\t\t\t\t\tif (preg_match($pattern, $mime))\n\t\t\t\t\t{\n\t\t\t\t\t\treturn $format;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} // End HTTP_ACCEPT checking\n\n\t\t// Well, none of that has worked! Let's see if the controller has a default\n\t\tif ( ! empty($this->rest_format))\n\t\t{\n\t\t\treturn $this->rest_format;\n\t\t}\n\n\t\t// Just use the default format\n\t\treturn \\Config::get('rest.default_format');\n\t}\n\n\t/**\n\t * Detect language(s)\n\t *\n\t * What language do they want it in?\n\t *\n\t * @return  null|array|string\n\t */\n\tprotected function _detect_lang()\n\t{\n\t\tif (!$lang = \\Input::server('HTTP_ACCEPT_LANGUAGE'))\n\t\t{\n\t\t\treturn null;\n\t\t}\n\n\t\t// They might have sent a few, make it an array\n\t\tif (strpos($lang, ',') !== false)\n\t\t{\n\t\t\t$langs = explode(',', $lang);\n\n\t\t\t$return_langs = array();\n\n\t\t\tforeach ($langs as $lang)\n\t\t\t{\n\t\t\t\t// Remove weight and strip space\n\t\t\t\tlist($lang) = explode(';', $lang);\n\t\t\t\t$return_langs[] = trim($lang);\n\t\t\t}\n\n\t\t\treturn $return_langs;\n\t\t}\n\n\t\t// Nope, just return the string\n\t\treturn $lang;\n\t}\n\n\t// SECURITY FUNCTIONS ---------------------------------------------------------\n\n\tprotected function _check_login($username = '', $password = null)\n\t{\n\t\tif (empty($username))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\n\t\t$valid_logins = \\Config::get('rest.valid_logins');\n\n\t\tif (!array_key_exists($username, $valid_logins))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\n\t\t// If actually null (not empty string) then do not check it\n\t\tif ($password !== null and $valid_logins[$username] != $password)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tprotected function _prepare_basic_auth()\n\t{\n\t\t$username = null;\n\t\t$password = null;\n\n\t\t// mod_php\n\t\tif (\\Input::server('PHP_AUTH_USER'))\n\t\t{\n\t\t\t$username = \\Input::server('PHP_AUTH_USER');\n\t\t\t$password = \\Input::server('PHP_AUTH_PW');\n\t\t}\n\n\t\t// most other servers\n\t\telseif (\\Input::server('HTTP_AUTHENTICATION'))\n\t\t{\n\t\t\tif (strpos(strtolower(\\Input::server('HTTP_AUTHENTICATION')), 'basic') === 0)\n\t\t\t{\n\t\t\t\tlist($username, $password) = explode(':', base64_decode(substr(\\Input::server('HTTP_AUTHORIZATION'), 6)));\n\t\t\t}\n\t\t}\n\n\t\tif ( ! static::_check_login($username, $password))\n\t\t{\n\t\t\tstatic::_force_login();\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tprotected function _prepare_digest_auth()\n\t{\n\t\t// Empty argument for backward compatibility\n\t\t$uniqid = uniqid(\"\");\n\n\t\t// We need to test which server authentication variable to use\n\t\t// because the PHP ISAPI module in IIS acts different from CGI\n\t\tif (\\Input::server('PHP_AUTH_DIGEST'))\n\t\t{\n\t\t\t$digest_string = \\Input::server('PHP_AUTH_DIGEST');\n\t\t}\n\t\telseif (\\Input::server('HTTP_AUTHORIZATION'))\n\t\t{\n\t\t\t$digest_string = \\Input::server('HTTP_AUTHORIZATION');\n\t\t}\n\t\telse\n\t\t{\n\t\t\t$digest_string = '';\n\t\t}\n\n\t\t// Prompt for authentication if we don't have a digest string\n\t\tif (empty($digest_string))\n\t\t{\n\t\t\tstatic::_force_login($uniqid);\n\t\t\treturn false;\n\t\t}\n\n\t\t// We need to retrieve authentication informations from the $digest_string variable\n\t\t$digest_params = explode(', ', $digest_string);\n\t\tforeach ($digest_params as $digest_param)\n\t\t{\n\t\t\t$digest_param = explode('=', $digest_param, 2);\n\t\t\tif (isset($digest_param[1]))\n\t\t\t{\n\t\t\t\t$digest[$digest_param[0]] = trim($digest_param[1], '\"');\n\t\t\t}\n\t\t}\n\n\t\t// if no username, or an invalid username found, re-authenticate\n\t\tif ( ! array_key_exists('username', $digest) or ! static::_check_login($digest['username']))\n\t\t{\n\t\t\tstatic::_force_login($uniqid);\n\t\t\treturn false;\n\t\t}\n\n\t\t// validate the configured login/password\n\t\t$valid_logins = \\Config::get('rest.valid_logins');\n\t\t$valid_pass = $valid_logins[$digest['username']];\n\n\t\t// This is the valid response expected\n\t\t$A1 = md5($digest['username'] . ':' . \\Config::get('rest.realm') . ':' . $valid_pass);\n\t\t$A2 = md5(strtoupper(\\Input::method()) . ':' . $digest['uri']);\n\t\t$valid_response = md5($A1 . ':' . $digest['nonce'] . ':' . $digest['nc'] . ':' . $digest['cnonce'] . ':' . $digest['qop'] . ':' . $A2);\n\n\t\tif ($digest['response'] != $valid_response)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tprotected function _force_login($nonce = '')\n\t{\n\t\t// Get the configured auth method if none is defined\n\t\t$this->auth === null and $this->auth = \\Config::get('rest.auth');\n\n\t\tif ($this->auth == 'basic')\n\t\t{\n\t\t\t$this->response->set_header('WWW-Authenticate', 'Basic realm=\"'. \\Config::get('rest.realm') . '\"');\n\t\t}\n\t\telseif ($this->auth == 'digest')\n\t\t{\n\t\t\t$this->response->set_header('WWW-Authenticate', 'Digest realm=\"' . \\Config::get('rest.realm') . '\", qop=\"auth\", nonce=\"' . $nonce . '\", opaque=\"' . md5(\\Config::get('rest.realm')) . '\"');\n\t\t}\n\t}\n\n}\n","markers":{"markers":{"1":{"id":1,"range":[[13,67],[13,67]],"tailed":false,"reversed":false,"valid":true,"invalidate":"never","persistent":true,"properties":{"type":"selection","editorId":8,"goalBufferRange":null},"deserializer":"Marker"}},"deserializer":"MarkerManager"},"history":{"undoStack":[],"redoStack":[],"deserializer":"History"},"filePath":"/Users/kwatanabe/git/whiteplus/hiroie/hiroie_api_develop/api.hiroie.jp/fuel/core/classes/controller/rest.php","modifiedWhenLastPersisted":false,"digestWhenLastPersisted":"bb4f36a22d0f52359eb689de51fa1561b3684ca2","deserializer":"TextBuffer"}],"deserializer":"Project"},"workspace":{"paneContainer":{"root":{"items":[{"id":8,"softTabs":false,"scrollTop":0,"scrollLeft":0,"displayBuffer":{"id":9,"softWrap":false,"editorWidthInChars":101,"tokenizedBuffer":{"bufferPath":"/Users/kwatanabe/git/whiteplus/hiroie/hiroie_api_develop/api.hiroie.jp/fuel/core/classes/controller/rest.php","tabLength":4,"deserializer":"TokenizedBuffer"},"deserializer":"DisplayBuffer"},"deserializer":"Editor"}],"activeItemUri":"/Users/kwatanabe/git/whiteplus/hiroie/hiroie_api_develop/api.hiroie.jp/fuel/core/classes/controller/rest.php","focused":true,"active":true,"deserializer":"Pane"},"deserializer":"PaneContainer"},"fullScreen":false,"deserializer":"Workspace"},"packageStates":{"find-and-replace":{"viewState":{"findHistory":[],"replaceHistory":[],"modelState":{"useRegex":false,"inCurrentSelection":false,"caseSensitive":false}}},"fuzzy-finder":{"/Users/kwatanabe/git/whiteplus/hiroie/hiroie_api_develop/api.hiroie.jp/fuel/core/classes/controller/rest.php":1396589523956},"keybinding-resolver":{"attached":false},"metrics":{"sessionLength":55271},"tree-view":{"directoryExpansionStates":{},"selectedPath":"/Users/kwatanabe/git/whiteplus/hiroie/hiroie_api_develop/api.hiroie.jp/fuel/core/classes/controller/rest.php","hasFocus":false,"attached":true,"scrollLeft":0,"scrollTop":0,"width":200}}}