{"mode":"editor","version":1,"windowDimensions":{"x":288,"y":56,"width":1632,"height":1024},"syntax":{"deserializer":"Syntax","grammarOverridesByPath":{}},"project":{"path":"/opt/local/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/site-packages/rst2pdf","buffers":[{"text":"# -*- coding: utf-8 -*-\n# See LICENSE.txt for licensing terms\n#$URL: https://rst2pdf.googlecode.com/svn/tags/0.92/rst2pdf/styles.py $\n#$Date: 2012-02-28 21:07:21 -0300 (Tue, 28 Feb 2012) $\n#$Revision: 2443 $\n\nimport os\nimport sys\nimport re\nfrom copy import copy\nfrom types import *\nfrom os.path import abspath, dirname, expanduser, join\n\nimport docutils.nodes\n\nimport reportlab\nfrom reportlab.platypus import *\nimport reportlab.lib.colors as colors\nimport reportlab.lib.units as units\nfrom reportlab.pdfbase.ttfonts import TTFont\nfrom reportlab.lib.fonts import addMapping\nfrom reportlab.lib.styles import *\nfrom reportlab.lib.enums import *\nfrom reportlab.pdfbase import pdfmetrics\nimport reportlab.lib.pagesizes as pagesizes\nimport reportlab.rl_config\n\nfrom rst2pdf.rson import loads as rson_loads\n\nimport findfonts\nfrom log import log\n\nfrom opt_imports import ParagraphStyle, wordaxe, wordaxe_version\n\nHAS_WORDAXE = wordaxe is not None\n\nunit_separator = re.compile('(-?[0-9\\.]*)')\n\n\nclass StyleSheet(object):\n    '''Class to handle a collection of stylesheets'''\n\n    @staticmethod\n    def stylepairs(data):\n        ''' Allows pairs of style information to be expressed\n            in canonical reportlab list of two-item list/tuple,\n            or in a more human-readable dictionary.\n        '''\n        styles = data.get('styles', {})\n        try:\n            stylenames = styles.keys()\n        except AttributeError:\n            for style in styles:\n                yield style\n            return\n\n        # Traditional reportlab styles are in ordered (key, value)\n        # tuples.  We also support dictionary lookup.  This is not\n        # necessarily ordered.\n\n        # The only problem with dictionary lookup is that\n        # we need to insure that parents are processed before\n        # their children.  This loop is a little ugly, but\n        # gets the job done.\n\n        while stylenames:\n            name = stylenames.pop()\n            parent = styles[name].get('parent')\n            if parent not in stylenames:\n                yield name, styles[name]\n                continue\n            names = [name]\n            while parent in stylenames:\n                stylenames.remove(parent)\n                names.append(parent)\n                parent = styles[names[-1]].get('parent')\n            while names:\n                name = names.pop()\n                yield name, styles[name]\n\n    def __init__(self, flist, font_path=None, style_path=None, def_dpi=300):\n        log.info('Using stylesheets: %s' % ','.join(flist))\n        # find base path\n        if hasattr(sys, 'frozen'):\n            self.PATH = abspath(dirname(sys.executable))\n        else:\n            self.PATH = abspath(dirname(__file__))\n\n        # flist is a list of stylesheet filenames.\n        # They will be loaded and merged in order.\n        # but the two default stylesheets will always\n        # be loaded first\n        flist = [join(self.PATH, 'styles', 'styles.style'),\n                join(self.PATH, 'styles', 'default.style')] + flist\n\n        self.def_dpi=def_dpi\n        if font_path is None:\n            font_path=[]\n        font_path+=['.', os.path.join(self.PATH, 'fonts')]\n        self.FontSearchPath = map(os.path.expanduser, font_path)\n\n        if style_path is None:\n            style_path=[]\n        style_path+=['.', os.path.join(self.PATH, 'styles'),\n                      '~/.rst2pdf/styles']\n        self.StyleSearchPath = map(os.path.expanduser, style_path)\n        self.FontSearchPath=list(set(self.FontSearchPath))\n        self.StyleSearchPath=list(set(self.StyleSearchPath))\n\n        log.info('FontPath:%s'%self.FontSearchPath)\n        log.info('StylePath:%s'%self.StyleSearchPath)\n\n        findfonts.flist = self.FontSearchPath\n        # Page width, height\n        self.pw = 0\n        self.ph = 0\n\n        # Page size [w,h]\n        self.ps = None\n\n        # Margins (top,bottom,left,right,gutter)\n        self.tm = 0\n        self.bm = 0\n        self.lm = 0\n        self.rm = 0\n        self.gm = 0\n\n        #text width\n        self.tw = 0\n\n        # Default emsize, later it will be the fontSize of the base style\n        self.emsize=10\n\n        self.languages = []\n\n        ssdata = self.readSheets(flist)\n\n        # Get pageSetup data from all stylessheets in order:\n        self.ps = pagesizes.A4\n        self.page={}\n        for data, ssname in ssdata:\n            page = data.get('pageSetup', {})\n            if page:\n                self.page.update(page)\n                pgs=page.get('size', None)\n                if pgs: # A standard size\n                    pgs=pgs.upper()\n                    if pgs in pagesizes.__dict__:\n                        self.ps = list(pagesizes.__dict__[pgs])\n                        self.psname = pgs\n                        if 'width' in self.page: del(self.page['width'])\n                        if 'height' in self.page: del(self.page['height'])\n                    elif pgs.endswith('-LANDSCAPE'):\n                        self.psname = pgs.split('-')[0]\n                        self.ps = list(pagesizes.landscape(pagesizes.__dict__[self.psname]))\n                        if 'width' in self.page: del(self.page['width'])\n                        if 'height' in self.page: del(self.page['height'])\n                    else:\n                        log.critical('Unknown page size %s in stylesheet %s'%\\\n                            (page['size'], ssname))\n                        continue\n                else: #A custom size\n                    if 'size'in self.page:\n                        del(self.page['size'])\n                    # The sizes are expressed in some unit.\n                    # For example, 2cm is 2 centimeters, and we need\n                    # to do 2*cm (cm comes from reportlab.lib.units)\n                    if 'width' in page:\n                        self.ps[0] = self.adjustUnits(page['width'])\n                    if 'height' in page:\n                        self.ps[1] = self.adjustUnits(page['height'])\n                self.pw, self.ph = self.ps\n                if 'margin-left' in page:\n                    self.lm = self.adjustUnits(page['margin-left'])\n                if 'margin-right' in page:\n                    self.rm = self.adjustUnits(page['margin-right'])\n                if 'margin-top' in page:\n                    self.tm = self.adjustUnits(page['margin-top'])\n                if 'margin-bottom' in page:\n                    self.bm = self.adjustUnits(page['margin-bottom'])\n                if 'margin-gutter' in page:\n                    self.gm = self.adjustUnits(page['margin-gutter'])\n                if 'spacing-header' in page:\n                    self.ts = self.adjustUnits(page['spacing-header'])\n                if 'spacing-footer' in page:\n                    self.bs = self.adjustUnits(page['spacing-footer'])\n                if 'firstTemplate' in page:\n                    self.firstTemplate = page['firstTemplate']\n\n                # tw is the text width.\n                # We need it to calculate header-footer height\n                # and compress literal blocks.\n                self.tw = self.pw - self.lm - self.rm - self.gm\n\n        # Get page templates from all stylesheets\n        self.pageTemplates = {}\n        for data, ssname in ssdata:\n            templates = data.get('pageTemplates', {})\n            # templates is a dictionary of pageTemplates\n            for key in templates:\n                template = templates[key]\n                # template is a dict.\n                # template[Â´frames'] is a list of frames\n                if key in self.pageTemplates:\n                    self.pageTemplates[key].update(template)\n                else:\n                    self.pageTemplates[key] = template\n\n        # Get font aliases from all stylesheets in order\n        self.fontsAlias = {}\n        for data, ssname in ssdata:\n            self.fontsAlias.update(data.get('fontsAlias', {}))\n\n        embedded_fontnames = []\n        self.embedded = []\n        # Embed all fonts indicated in all stylesheets\n        for data, ssname in ssdata:\n            embedded = data.get('embeddedFonts', [])\n\n            for font in embedded:\n                try:\n                    # Just a font name, try to embed it\n                    if isinstance(font, unicode):\n                        # See if we can find the font\n                        fname, pos = findfonts.guessFont(font)\n                        if font in embedded_fontnames:\n                            pass\n                        else:\n                            fontList = findfonts.autoEmbed(font)\n                            if fontList:\n                                embedded_fontnames.append(font)\n                        if not fontList:\n                            if (fname, pos) in embedded_fontnames:\n                                fontList = None\n                            else:\n                                fontList = findfonts.autoEmbed(fname)\n                        if fontList is not None:\n                            self.embedded += fontList\n                            # Maybe the font we got is not called\n                            # the same as the one we gave\n                            # so check that out\n                            suff = [\"\", \"-Oblique\", \"-Bold\", \"-BoldOblique\"]\n                            if not fontList[0].startswith(font):\n                                # We need to create font aliases, and use them\n                                for fname, aliasname in zip(\n                                        fontList,\n                                        [font + suffix for suffix in suff]):\n                                    self.fontsAlias[aliasname] = fname\n                        continue\n\n                    # Each \"font\" is a list of four files, which will be\n                    # used for regular / bold / italic / bold+italic\n                    # versions of the font.\n                    # If your font doesn't have one of them, just repeat\n                    # the regular font.\n\n                    # Example, using the Tuffy font from\n                    # http://tulrich.com/fonts/\n                    # \"embeddedFonts\" : [\n                    #                    [\"Tuffy.ttf\",\n                    #                     \"Tuffy_Bold.ttf\",\n                    #                     \"Tuffy_Italic.ttf\",\n                    #                     \"Tuffy_Bold_Italic.ttf\"]\n                    #                   ],\n\n                    # The fonts will be registered with the file name,\n                    # minus the extension.\n\n                    if font[0].lower().endswith('.ttf'): # A True Type font\n                        for variant in font:\n                            location=self.findFont(variant)\n                            pdfmetrics.registerFont(\n                                TTFont(str(variant.split('.')[0]),\n                                location))\n                            log.info('Registering font: %s from %s'%\\\n                                (str(variant.split('.')[0]),location))\n                            self.embedded.append(str(variant.split('.')[0]))\n\n                        # And map them all together\n                        regular, bold, italic, bolditalic = [\n                            variant.split('.')[0] for variant in font]\n                        addMapping(regular, 0, 0, regular)\n                        addMapping(regular, 0, 1, italic)\n                        addMapping(regular, 1, 0, bold)\n                        addMapping(regular, 1, 1, bolditalic)\n                    else: # A Type 1 font\n                        # For type 1 fonts we require\n                        # [FontName,regular,italic,bold,bolditalic]\n                        # where each variant is a (pfbfile,afmfile) pair.\n                        # For example, for the URW palladio from TeX:\n                        # [\"Palatino\",(\"uplr8a.pfb\",\"uplr8a.afm\"),\n                        #             (\"uplri8a.pfb\",\"uplri8a.afm\"),\n                        #             (\"uplb8a.pfb\",\"uplb8a.afm\"),\n                        #             (\"uplbi8a.pfb\",\"uplbi8a.afm\")]\n                        faceName = font[0]\n                        regular = pdfmetrics.EmbeddedType1Face(*font[1])\n                        italic = pdfmetrics.EmbeddedType1Face(*font[2])\n                        bold = pdfmetrics.EmbeddedType1Face(*font[3])\n                        bolditalic = pdfmetrics.EmbeddedType1Face(*font[4])\n\n                except Exception, e:\n                    try:\n                        if isinstance(font, list):\n                            fname = font[0]\n                        else:\n                            fname = font\n                        log.error(\"Error processing font %s: %s\",\n                            os.path.splitext(fname)[0], str(e))\n                        log.error(\"Registering %s as Helvetica alias\", fname)\n                        self.fontsAlias[fname] = 'Helvetica'\n                    except Exception, e:\n                        log.critical(\"Error processing font %s: %s\",\n                            fname, str(e))\n                        continue\n\n        # Go though all styles in all stylesheets and find all fontNames.\n        # Then decide what to do with them\n        for data, ssname in ssdata:\n            for [skey, style] in self.stylepairs(data):\n                for key in style:\n                    if key == 'fontName' or key.endswith('FontName'):\n                        # It's an alias, replace it\n                        if style[key] in self.fontsAlias:\n                            style[key] = self.fontsAlias[style[key]]\n                        # Embedded already, nothing to do\n                        if style[key] in self.embedded:\n                            continue\n                        # Standard font, nothing to do\n                        if style[key] in (\n                                    \"Courier\",\n                                    \"Courier-Bold\",\n                                    \"Courier-BoldOblique\",\n                                    \"Courier-Oblique\",\n                                    \"Helvetica\",\n                                    \"Helvetica-Bold\",\n                                    \"Helvetica-BoldOblique\",\n                                    \"Helvetica-Oblique\",\n                                    \"Symbol\",\n                                    \"Times-Bold\",\n                                    \"Times-BoldItalic\",\n                                    \"Times-Italic\",\n                                    \"Times-Roman\",\n                                    \"ZapfDingbats\"):\n                            continue\n                        # Now we need to do something\n                        # See if we can find the font\n                        fname, pos = findfonts.guessFont(style[key])\n\n                        if style[key] in embedded_fontnames:\n                            pass\n                        else:\n                            fontList = findfonts.autoEmbed(style[key])\n                            if fontList:\n                                embedded_fontnames.append(style[key])\n                        if not fontList:\n                            if (fname, pos) in embedded_fontnames:\n                                fontList = None\n                            else:\n                                fontList = findfonts.autoEmbed(fname)\n                            if fontList:\n                                embedded_fontnames.append((fname, pos))\n                        if fontList:\n                            self.embedded += fontList\n                            # Maybe the font we got is not called\n                            # the same as the one we gave so check that out\n                            suff = [\"\", \"-Bold\", \"-Oblique\", \"-BoldOblique\"]\n                            if not fontList[0].startswith(style[key]):\n                                # We need to create font aliases, and use them\n                                basefname=style[key].split('-')[0]\n                                for fname, aliasname in zip(\n                                        fontList,\n                                        [basefname + suffix for\n                                        suffix in suff]):\n                                    self.fontsAlias[aliasname] = fname\n                                style[key] = self.fontsAlias[basefname +\\\n                                             suff[pos]]\n                        else:\n                            log.error(\"Unknown font: \\\"%s\\\",\"\n                                      \"replacing with Helvetica\", style[key])\n                            style[key] = \"Helvetica\"\n\n        #log.info('FontList: %s'%self.embedded)\n        #log.info('FontAlias: %s'%self.fontsAlias)\n        # Get styles from all stylesheets in order\n        self.stylesheet = {}\n        self.styles = []\n        self.linkColor = 'navy'\n        # FIXME: linkColor should probably not be a global\n        #        style, and tocColor should probably not\n        #        be a special case, but for now I'm going\n        #        with the flow...\n        self.tocColor = None\n        for data, ssname in ssdata:\n            self.linkColor = data.get('linkColor') or self.linkColor\n            self.tocColor = data.get('tocColor') or self.tocColor\n            for [skey, style] in self.stylepairs(data):\n                sdict = {}\n                # FIXME: this is done completely backwards\n                for key in style:\n                    # Handle color references by name\n                    if key == 'color' or key.endswith('Color') and style[key]:\n                        style[key] = formatColor(style[key])\n\n                    # Yet another workaround for the unicode bug in\n                    # reportlab's toColor\n                    elif key == 'commands':\n                        style[key]=validateCommands(style[key])\n                        #for command in style[key]:\n                            #c=command[0].upper()\n                            #if c=='ROWBACKGROUNDS':\n                                #command[3]=[str(c) for c in command[3]]\n                            #elif c in ['BOX','INNERGRID'] or c.startswith('LINE'):\n                                #command[4]=str(command[4])\n\n                    # Handle alignment constants\n                    elif key == 'alignment':\n                        style[key] = dict(TA_LEFT=0,\n                                          LEFT=0,\n                                          TA_CENTER=1,\n                                          CENTER=1,\n                                          TA_CENTRE=1,\n                                          CENTRE=1,\n                                          TA_RIGHT=2,\n                                          RIGHT=2,\n                                          TA_JUSTIFY=4,\n                                          JUSTIFY=4,\n                                          DECIMAL=8, )[style[key].upper()]\n\n                    elif key == 'language':\n                        if not style[key] in self.languages:\n                            self.languages.append(style[key])\n\n                    # Make keys str instead of unicode (required by reportlab)\n                    sdict[str(key)] = style[key]\n                    sdict['name'] = skey\n                # If the style already exists, update it\n                if skey in self.stylesheet:\n                    self.stylesheet[skey].update(sdict)\n                else: # New style\n                    self.stylesheet[skey] = sdict\n                    self.styles.append(sdict)\n\n        # If the stylesheet has a style name docutils won't reach\n        # make a copy with a sanitized name.\n        # This may make name collisions possible but that should be\n        # rare (who would have custom_name and custom-name in the\n        # same stylesheet? ;-)\n        # Issue 339\n\n        styles2=[]\n        for s in self.styles:\n            if not re.match(\"^[a-z](-?[a-z0-9]+)*$\", s['name']):\n                s2 = copy(s)\n                s2['name'] = docutils.nodes.make_id(s['name'])\n                log.warning('%s is an invalid docutils class name, adding alias %s'%(s['name'], s2['name']))\n                styles2.append(s2)\n        self.styles.extend(styles2)\n\n        # And create  reportlabs stylesheet\n        self.StyleSheet = StyleSheet1()\n        # Patch to make the code compatible with reportlab from SVN 2.4+ and\n        # 2.4\n        if not hasattr(self.StyleSheet, 'has_key'):\n            self.StyleSheet.__class__.has_key = lambda s, k : k in s\n        for s in self.styles:\n            if 'parent' in s:\n                if s['parent'] is None:\n                    if s['name'] != 'base':\n                        s['parent'] = self.StyleSheet['base']\n                    else:\n                        del(s['parent'])\n                else:\n                    s['parent'] = self.StyleSheet[s['parent']]\n            else:\n                if s['name'] != 'base':\n                    s['parent'] = self.StyleSheet['base']\n\n            # If the style has no bulletFontName but it has a fontName, set it\n            if ('bulletFontName' not in s) and ('fontName' in s):\n                s['bulletFontName'] = s['fontName']\n\n            hasFS = True\n            # Adjust fontsize units\n            if 'fontSize' not in s:\n                s['fontSize'] = s['parent'].fontSize\n                s['trueFontSize']=None\n                hasFS = False\n            elif 'parent' in s:\n                # This means you can set the fontSize to\n                # \"2cm\" or to \"150%\" which will be calculated\n                # relative to the parent style\n                s['fontSize'] = self.adjustUnits(s['fontSize'],\n                                    s['parent'].fontSize)\n                s['trueFontSize']=s['fontSize']\n            else:\n                # If s has no parent, it's base, which has\n                # an explicit point size by default and %\n                # makes no sense, but guess it as % of 10pt\n                s['fontSize'] = self.adjustUnits(s['fontSize'], 10)\n\n            # If the leading is not set, but the size is, set it\n            if 'leading' not in s and hasFS:\n                s['leading'] = 1.2*s['fontSize']\n\n            # If the bullet font size is not set, set it as fontSize\n            if ('bulletFontSize' not in s) and ('fontSize' in s):\n                s['bulletFontSize'] = s['fontSize']\n\n            # If the borderPadding is a list and wordaxe <=0.3.2,\n            # convert it to an integer. Workaround for Issue\n            if 'borderPadding' in s and ((HAS_WORDAXE and \\\n                    wordaxe_version <='wordaxe 0.3.2') or\n                    reportlab.Version < \"2.3\" )\\\n                    and isinstance(s['borderPadding'], list):\n                log.warning('Using a borderPadding list in '\\\n                    'style %s with wordaxe <= 0.3.2 or Reportlab < 2.3. That is not '\\\n                    'supported, so it will probably look wrong'%s['name'])\n                s['borderPadding']=s['borderPadding'][0]\n\n            self.StyleSheet.add(ParagraphStyle(**s))\n\n\n        self.emsize=self['base'].fontSize\n        # Make stdFont the basefont, for Issue 65\n        reportlab.rl_config.canvas_basefontname = self['base'].fontName\n        # Make stdFont the default font for table cell styles (Issue 65)\n        reportlab.platypus.tables.CellStyle.fontname=self['base'].fontName\n\n\n    def __getitem__(self, key):\n\n        # This 'normalizes' the key.\n        # For example, if the key is todo_node (like sphinx uses), it will be\n        # converted to 'todo-node' which is a valid docutils class name.\n\n        if not re.match(\"^[a-z](-?[a-z0-9]+)*$\", key):\n            key = docutils.nodes.make_id(key)\n\n        if self.StyleSheet.has_key(key):\n            return self.StyleSheet[key]\n        else:\n            if key.startswith('pygments'):\n                log.info(\"Using undefined style '%s'\"\n                            \", aliased to style 'code'.\"%key)\n                newst=copy(self.StyleSheet['code'])\n            else:\n                log.warning(\"Using undefined style '%s'\"\n                            \", aliased to style 'normal'.\"%key)\n                newst=copy(self.StyleSheet['normal'])\n            newst.name=key\n            self.StyleSheet.add(newst)\n            return newst\n\n    def readSheets(self, flist):\n        ''' Read in the stylesheets.  Return a list of\n            (sheetdata, sheetname) tuples.\n\n            Orders included sheets in front\n            of including sheets.\n        '''\n        # Process from end of flist\n        flist.reverse()\n        # Keep previously seen sheets in sheetdict\n        sheetdict = {}\n        result = []\n\n        while flist:\n            ssname = flist.pop()\n            data = sheetdict.get(ssname)\n            if data is None:\n                data = self.readStyle(ssname)\n                if data is None:\n                    continue\n                sheetdict[ssname] = data\n                if 'options' in data and 'stylesheets' in data['options']:\n                    flist.append(ssname)\n                    newsheets = list(data['options']['stylesheets'])\n                    newsheets.reverse()\n                    flist.extend(newsheets)\n                    continue\n            result.append((data, ssname))\n        return result\n\n    def readStyle(self, ssname):\n            # If callables are used, they should probably be subclassed\n            # strings, or something else that will print nicely for errors\n            if callable(ssname):\n                return ssname()\n\n            fname = self.findStyle(ssname)\n            if fname:\n                try:\n                    return rson_loads(open(fname).read())\n                except ValueError, e: # Error parsing the JSON data\n                    log.critical('Error parsing stylesheet \"%s\": %s'%\\\n                        (fname, str(e)))\n                except IOError, e: #Error opening the ssheet\n                    log.critical('Error opening stylesheet \"%s\": %s'%\\\n                        (fname, str(e)))\n\n    def findStyle(self, fn):\n        \"\"\"Find the absolute file name for a given style filename.\n\n        Given a style filename, searches for it in StyleSearchPath\n        and returns the real file name.\n\n        \"\"\"\n\n        def innerFind(path, fn):\n            if os.path.isabs(fn):\n                if os.path.isfile(fn):\n                    return fn\n            else:\n                for D in path:\n                    tfn = os.path.join(D, fn)\n                    if os.path.isfile(tfn):\n                        return tfn\n            return None\n        for ext in ['', '.style', '.json']:\n            result = innerFind(self.StyleSearchPath, fn+ext)\n            if result:\n                break\n        if result is None:\n            log.warning(\"Can't find stylesheet %s\"%fn)\n        return result\n\n    def findFont(self, fn):\n        \"\"\"Find the absolute font name for a given font filename.\n\n        Given a font filename, searches for it in FontSearchPath\n        and returns the real file name.\n\n        \"\"\"\n        if not os.path.isabs(fn):\n            for D in self.FontSearchPath:\n                tfn = os.path.join(D, fn)\n                if os.path.isfile(tfn):\n                    return str(tfn)\n        return str(fn)\n\n    def styleForNode(self, node):\n        \"\"\"Return the right default style for any kind of node.\n\n        That usually means \"bodytext\", but for sidebars, for\n        example, it's sidebar.\n\n        \"\"\"\n        n= docutils.nodes\n        styles={n.sidebar: 'sidebar',\n                n.figure: 'figure',\n                n.tgroup: 'table',\n                n.table: 'table',\n                n.Admonition: 'admonition'\n        }\n\n        return self[styles.get(node.__class__, 'bodytext')]\n\n    def tstyleHead(self, rows=1):\n        \"\"\"Return a table style spec for a table header of `rows`.\n\n        The style will be based on the table-heading style from the stylesheet.\n\n        \"\"\"\n        # This alignment thing is exactly backwards from\n        # the alignment for paragraphstyles\n        alignment = {0: 'LEFT', 1: 'CENTER', 1: 'CENTRE', 2: 'RIGHT',\n            4: 'JUSTIFY', 8: 'DECIMAL'}[self['table-heading'].alignment]\n        return [\n            ('BACKGROUND',\n                (0, 0),\n                (-1, rows - 1),\n                self['table-heading'].backColor),\n            ('ALIGN',\n                (0, 0),\n                (-1, rows - 1),\n                alignment),\n            ('TEXTCOLOR',\n                (0, 0),\n                (-1, rows - 1),\n                self['table-heading'].textColor),\n            ('FONT',\n                (0, 0),\n                (-1, rows - 1),\n                self['table-heading'].fontName,\n                self['table-heading'].fontSize,\n                self['table-heading'].leading),\n            ('VALIGN',\n                (0, 0),\n                (-1, rows - 1),\n                self['table-heading'].valign)]\n\n    def adjustFieldStyle(self):\n        \"\"\"Merges fieldname and fieldvalue styles into the field table style\"\"\"\n        tstyle=self.tstyles['field']\n        extras=self.pStyleToTStyle(self['fieldname'], 0, 0)+\\\n                self.pStyleToTStyle(self['fieldvalue'], 1, 0)\n        for e in extras:\n            tstyle.add(*e)\n        return tstyle\n\n    def pStyleToTStyle(self, style, x, y):\n        \"\"\"Return a table style similar to a given paragraph style.\n\n        Given a reportlab paragraph style, returns a spec for a table style\n        that adopts some of its features (for example, the background color).\n\n        \"\"\"\n        results = []\n        if style.backColor:\n            results.append(('BACKGROUND', (x, y), (x, y), style.backColor))\n        if style.borderWidth:\n            bw = style.borderWidth\n            del style.__dict__['borderWidth']\n            if style.borderColor:\n                bc = style.borderColor\n                del style.__dict__['borderColor']\n            else:\n                bc = colors.black\n            bc=str(bc)\n            results.append(('BOX', (x, y), (x, y), bw, bc))\n        if style.borderPadding:\n            if isinstance(style.borderPadding, list):\n                results.append(('TOPPADDING',\n                    (x, y),\n                    (x, y),\n                    style.borderPadding[0]))\n                results.append(('RIGHTPADDING',\n                    (x, y),\n                    (x, y),\n                    style.borderPadding[1]))\n                results.append(('BOTTOMPADDING',\n                    (x, y),\n                    (x, y),\n                    style.borderPadding[2]))\n                results.append(('LEFTPADDING',\n                    (x, y),\n                    (x, y),\n                    style.borderPadding[3]))\n            else:\n                results.append(('TOPPADDING',\n                    (x, y),\n                    (x, y),\n                    style.borderPadding))\n                results.append(('RIGHTPADDING',\n                    (x, y),\n                    (x, y),\n                    style.borderPadding))\n                results.append(('BOTTOMPADDING',\n                    (x, y),\n                    (x, y),\n                    style.borderPadding))\n                results.append(('LEFTPADDING',\n                    (x, y),\n                    (x, y),\n                    style.borderPadding))\n        return results\n\n    def adjustUnits(self, v, total=None, default_unit='pt'):\n        if total is None:\n            total = self.tw\n        return adjustUnits(v, total,\n                           self.def_dpi,\n                           default_unit,\n                           emsize=self.emsize)\n\n    def combinedStyle(self, styles):\n        '''Given a list of style names, it merges them (the existing ones)\n        and returns a new style.\n\n        The styles that don't exist are silently ignored.\n\n        For example, if called with styles=['style1','style2'] the returned\n        style will be called 'merged_style1_style2'.\n\n        The styles that are *later* in the list will have priority.\n        '''\n\n        validst = [x for x in styles if self.StyleSheet.has_key(x)]\n        newname = '_'.join(['merged']+validst)\n        validst = [self[x] for x in validst]\n        newst=copy(validst[0])\n\n        for st in validst[1:]:\n            newst.__dict__.update(st.__dict__)\n\n        newst.name=newname\n        return newst\n\n\ndef adjustUnits(v, total=None, dpi=300, default_unit='pt', emsize=10):\n    \"\"\"Takes something like 2cm and returns 2*cm.\n\n    If you use % as a unit, it returns the percentage of \"total\".\n\n    If total is not given, returns a percentage of the page width.\n    However, if you get to that stage, you are doing it wrong.\n\n    Example::\n\n            >>> adjustUnits('50%',200)\n            100\n\n    \"\"\"\n\n    if v is None or v==\"\":\n        return None\n\n    v = str(v)\n    l = re.split('(-?[0-9\\.]*)', v)\n    n=l[1]\n    u=default_unit\n    if len(l) == 3 and l[2]:\n        u=l[2]\n    if u in units.__dict__:\n        return float(n) * units.__dict__[u]\n    else:\n        if u == '%':\n            return float(n) * total/100\n        elif u=='px':\n            return float(n) * units.inch / dpi\n        elif u=='pt':\n            return float(n)\n        elif u=='in':\n            return float(n) * units.inch\n        elif u=='em':\n            return float(n) * emsize\n        elif u=='ex':\n            return float(n) * emsize /2\n        elif u=='pc': # picas!\n            return float(n) * 12\n        log.error('Unknown unit \"%s\"' % u)\n    return float(n)\n\n\ndef formatColor(value, numeric=True):\n    \"\"\"Convert a color like \"gray\" or \"0xf\" or \"ffff\"\n    to something ReportLab will like.\"\"\"\n    if value in colors.__dict__:\n        return colors.__dict__[value]\n    else: # Hopefully, a hex color:\n        c = value.strip()\n        if c[0] == '#':\n            c = c[1:]\n        while len(c) < 6:\n            c = '0' + c\n        if numeric:\n            r = int(c[:2], 16)/255.\n            g = int(c[2:4], 16)/255.\n            b = int(c[4:6], 16)/255.\n            if len(c) >= 8:\n                alpha = int(c[6:8], 16)/255.\n                return colors.Color(r, g, b, alpha=alpha)\n            return colors.Color(r, g, b)\n        else:\n            return str(\"#\"+c)\n\n# The values are:\n# * Minimum number of arguments\n# * Maximum number of arguments\n# * Valid types of arguments.\n#\n# For example, if option FOO takes a list a string and a number,\n# but the number is optional:\n#\n# \"FOO\":(2,3,\"list\",\"string\",\"number\")\n#\n# The reportlab command could look like\n#\n# [\"FOO\",(0,0),(-1,-1),[1,2],\"whatever\",4]\n#\n# THe (0,0) (-1,-1) are start and stop and are mandatory.\n#\n# Possible types of arguments are string, number, color, colorlist\n\n\nvalidCommands={\n        # Cell format commands\n        \"FONT\":(1,3,\"string\",\"number\",\"number\"),\n        \"FONTNAME\":(1,1,\"string\"),\n        \"FACE\":(1,1,\"string\"),\n        \"FONTSIZE\":(1,1,\"number\"),\n        \"SIZE\":(1,1,\"number\"),\n        \"LEADING\":(1,1,\"number\"),\n        \"TEXTCOLOR\":(1,1,\"color\"),\n        \"ALIGNMENT\":(1,1,\"string\"),\n        \"ALIGN\":(1,1,\"string\"),\n        \"LEFTPADDING\":(1,1,\"number\"),\n        \"RIGHTPADDING\":(1,1,\"number\"),\n        \"TOPPADDING\":(1,1,\"number\"),\n        \"BOTTOMPADDING\":(1,1,\"number\"),\n        \"BACKGROUND\":(1,1,\"color\"),\n        \"ROWBACKGROUNDS\":(1,1,\"colorlist\"),\n        \"COLBACKGROUNDS\":(1,1,\"colorlist\"),\n        \"VALIGN\":(1,1,\"string\"),\n        # Line commands\n        \"GRID\":(2,2,\"number\",\"color\"),\n        \"BOX\":(2,2,\"number\",\"color\"),\n        \"OUTLINE\":(2,2,\"number\",\"color\"),\n        \"INNERGRID\":(2,2,\"number\",\"color\"),\n        \"LINEBELOW\":(2,2,\"number\",\"color\"),\n        \"LINEABOVE\":(2,2,\"number\",\"color\"),\n        \"LINEBEFORE\":(2,2,\"number\",\"color\"),\n        \"LINEAFTER\":(2,2,\"number\",\"color\"),\n        # You should NOT have span commands, man!\n        #\"SPAN\":(,,),\n    }\n\ndef validateCommands(commands):\n    '''Given a list of reportlab's table commands, it fixes some common errors\n    and/or removes commands that can't be fixed'''\n\n    fixed=[]\n\n    for command in commands:\n        command[0]=command[0].upper()\n        flag=False\n        # See if the command is valid\n        if command[0] not in validCommands:\n            log.error('Unknown table command %s in stylesheet',command[0])\n            continue\n\n        # See if start and stop are the right types\n        if type(command[1]) not in (ListType,TupleType):\n            log.error('Start cell in table command should be list or tuple, got %s [%s]',type(command[1]),command[1])\n            flag=True\n\n        if type(command[2]) not in (ListType,TupleType):\n            log.error('Stop cell in table command should be list or tuple, got %s [%s]',type(command[1]),command[1])\n            flag=True\n\n        # See if the number of arguments is right\n        l=len(command)-3\n        if l>validCommands[command[0]][1]:\n            log.error('Too many arguments in table command: %s',command)\n            flag=True\n\n        if l<validCommands[command[0]][0]:\n            log.error('Too few arguments in table command: %s',command)\n            flag=True\n\n        # Validate argument types\n        for pos,arg in enumerate(command[3:]):\n            typ = validCommands[command[0]][pos+2]\n            if typ == \"color\":\n                # Convert all 'string' colors to numeric\n                command[3+pos]=formatColor(arg)\n            elif typ == \"colorlist\":\n                command[3+pos]=[ formatColor(c) for c in arg]\n            elif typ == \"number\":\n                pass\n            elif typ == \"string\":\n                # Force string, not unicode\n                command[3+pos]=str(arg)\n            else:\n                log.error(\"This should never happen: wrong type %s\",typ)\n\n        if not flag:\n            fixed.append(command)\n\n    return fixed\n\nclass CallableStyleSheet(str):\n    ''' Useful for programmatically generated stylesheets.\n        A generated stylesheet is a callable string (name),\n        which returns the pre-digested stylesheet data\n        when called.\n    '''\n    def __new__(cls, name, value=''):\n        self = str.__new__(cls, name)\n        self.value = value\n        return self\n    def __call__(self):\n        return rson_loads(self.value)\n","markers":{"markers":{"1":{"id":1,"range":[[526,43],[526,43]],"tailed":false,"reversed":true,"valid":true,"invalidate":"never","persistent":true,"properties":{"type":"selection","editorId":78,"goalBufferRange":null,"autoscroll":true},"deserializer":"Marker"}},"deserializer":"MarkerManager"},"history":{"undoStack":[{"patches":[{"id":1,"oldParams":{"tailed":false},"newParams":{"tailed":true},"deserializer":"MarkerPatch"},{"id":1,"oldParams":{"reversed":false,"range":[[526,44],[526,44]]},"newParams":{"reversed":true,"range":[[526,43],[526,44]]},"deserializer":"MarkerPatch"},{"oldRange":[[526,43],[526,44]],"newRange":[[526,43],[526,43]],"oldText":"1","newText":"","normalizeLineEndings":true,"markerPatches":{},"deserializer":"BufferPatch"},{"id":1,"oldParams":{"tailed":true},"newParams":{"tailed":false},"deserializer":"MarkerPatch"}],"deserializer":"Transaction"},{"patches":[{"oldRange":[[973,0],[974,0]],"newRange":[[973,0],[973,0]],"oldText":"\n","newText":"","normalizeLineEndings":true,"markerPatches":{},"deserializer":"BufferPatch"}],"deserializer":"Transaction"}],"redoStack":[],"deserializer":"History"},"filePath":"/opt/local/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/site-packages/rst2pdf/styles.py","modifiedWhenLastPersisted":false,"digestWhenLastPersisted":"920d0fd6c41b09c6f3e61e100ff20ccc86e84c4f","deserializer":"TextBuffer"}],"deserializer":"Project"},"workspace":{"paneContainer":{"root":{"items":[{"id":78,"softTabs":true,"displayBuffer":{"id":79,"softWrap":false,"editorWidthInChars":157,"scrollTop":9588,"scrollLeft":0,"tokenizedBuffer":{"bufferPath":"/opt/local/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/site-packages/rst2pdf/styles.py","tabLength":4,"deserializer":"TokenizedBuffer"},"deserializer":"DisplayBuffer"},"deserializer":"Editor"}],"activeItemUri":"/opt/local/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/site-packages/rst2pdf/styles.py","focused":true,"active":true,"deserializer":"Pane"},"deserializer":"PaneContainer"},"fullScreen":false,"deserializer":"Workspace"},"packageStates":{"script":{"scriptOptionsViewState":""},"find-and-replace":{"viewState":{"findHistory":["CellStyle"],"replaceHistory":[],"modelState":{"useRegex":false,"inCurrentSelection":false,"caseSensitive":false}}},"fuzzy-finder":{"/opt/local/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/site-packages/rst2pdf/styles.py":1403145702640},"keybinding-resolver":{"attached":false},"metrics":{"sessionLength":33910},"tree-view":{"directoryExpansionStates":{},"selectedPath":"/opt/local/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/site-packages/rst2pdf/styles.py","hasFocus":false,"attached":true,"scrollLeft":0,"scrollTop":0,"width":200}}}