{"mode":"editor","version":1,"windowDimensions":{"x":554,"y":56,"width":1024,"height":1024},"syntax":{"deserializer":"Syntax","grammarOverridesByPath":{}},"project":{"path":"/Users/kwatanabe/git/whiteplus/hiroie/hiroie_api_develop/api.hiroie.jp/fuel/core/classes","buffers":[{"text":"<?php\n/**\n * Part of the Fuel framework.\n *\n * @package    Fuel\n * @version    1.7\n * @author     Fuel Development Team\n * @license    MIT License\n * @copyright  2010 - 2014 Fuel Development Team\n * @link       http://fuelphp.com\n */\n\nnamespace Fuel\\Core;\n\n/**\n * The Autloader is responsible for all class loading.  It allows you to define\n * different load paths based on namespaces.  It also lets you set explicit paths\n * for classes to be loaded from.\n *\n * @package     Fuel\n * @subpackage  Core\n */\nclass Autoloader\n{\n\n\t/**\n\t * @var  array  $classes  holds all the classes and paths\n\t */\n\tprotected static $classes = array();\n\n\t/**\n\t * @var  array  holds all the namespace paths\n\t */\n\tprotected static $namespaces = array();\n\n\t/**\n\t * Holds all the PSR-0 compliant namespaces.  These namespaces should\n\t * be loaded according to the PSR-0 standard.\n\t *\n\t * @var  array\n\t */\n\tprotected static $psr_namespaces = array();\n\n\t/**\n\t * @var  array  list off namespaces of which classes will be aliased to global namespace\n\t */\n\tprotected static $core_namespaces = array(\n\t\t'Fuel\\\\Core'\n\t);\n\n\t/**\n\t * @var  array  the default path to look in if the class is not in a package\n\t */\n\tprotected static $default_path = null;\n\n\t/**\n\t * @var  bool  whether to initialize a loaded class\n\t */\n\tprotected static $auto_initialize = null;\n\n\t/**\n\t * Adds a namespace search path.  Any class in the given namespace will be\n\t * looked for in the given path.\n\t *\n\t * @param   string  the namespace\n\t * @param   string  the path\n\t * @return  void\n\t */\n\tpublic static function add_namespace($namespace, $path, $psr = false)\n\t{\n\t\tstatic::$namespaces[$namespace] = $path;\n\t\tif ($psr)\n\t\t{\n\t\t\tstatic::$psr_namespaces[$namespace] = $path;\n\t\t}\n\t}\n\n\t/**\n\t * Adds an array of namespace paths. See {add_namespace}.\n\t *\n\t * @param   array  the namespaces\n\t * @param   bool   whether to prepend the namespace to the search path\n\t * @return  void\n\t */\n\tpublic static function add_namespaces(array $namespaces, $prepend = false)\n\t{\n\t\tif ( ! $prepend)\n\t\t{\n\t\t\tstatic::$namespaces = array_merge(static::$namespaces, $namespaces);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tstatic::$namespaces = $namespaces + static::$namespaces;\n\t\t}\n\t}\n\n\t/**\n\t * Returns the namespace's path or false when it doesn't exist.\n\t *\n\t * @param   string      the namespace to get the path for\n\t * @return  array|bool  the namespace path or false\n\t */\n\tpublic static function namespace_path($namespace)\n\t{\n\t\tif ( ! array_key_exists($namespace, static::$namespaces))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\n\t\treturn static::$namespaces[$namespace];\n\t}\n\n\t/**\n\t * Adds a classes load path.  Any class added here will not be searched for\n\t * but explicitly loaded from the path.\n\t *\n\t * @param   string  the class name\n\t * @param   string  the path to the class file\n\t * @return  void\n\t */\n\tpublic static function add_class($class, $path)\n\t{\n\t\tstatic::$classes[$class] = $path;\n\t}\n\n\t/**\n\t * Adds multiple class paths to the load path. See {@see Autoloader::add_class}.\n\t *\n\t * @param   array  the class names and paths\n\t * @return  void\n\t */\n\tpublic static function add_classes($classes)\n\t{\n\t\tforeach ($classes as $class => $path)\n\t\t{\n\t\t\tstatic::$classes[$class] = $path;\n\t\t}\n\t}\n\n\t/**\n\t * Aliases the given class into the given Namespace.  By default it will\n\t * add it to the global namespace.\n\t *\n\t * <code>\n\t * Autoloader::alias_to_namespace('Foo\\\\Bar');\n\t * Autoloader::alias_to_namespace('Foo\\\\Bar', '\\\\Baz');\n\t * </code>\n\t *\n\t * @param  string  $class      the class name\n\t * @param  string  $namespace  the namespace to alias to\n\t */\n\tpublic static function alias_to_namespace($class, $namespace = '')\n\t{\n\t\tempty($namespace) or $namespace = rtrim($namespace, '\\\\').'\\\\';\n\t\t$parts = explode('\\\\', $class);\n\t\t$root_class = $namespace.array_pop($parts);\n\t\tclass_alias($class, $root_class);\n\t}\n\n\t/**\n\t * Register's the autoloader to the SPL autoload stack.\n\t *\n\t * @return\tvoid\n\t */\n\tpublic static function register()\n\t{\n\t\tspl_autoload_register('Autoloader::load', true, true);\n\t}\n\n\t/**\n\t * Returns the class with namespace prefix when available\n\t *\n\t * @param\tstring\n\t * @return\tbool|string\n\t */\n\tprotected static function find_core_class($class)\n\t{\n\t\tforeach (static::$core_namespaces as $ns)\n\t\t{\n\t\t\tif (array_key_exists($ns_class = $ns.'\\\\'.$class, static::$classes))\n\t\t\t{\n\t\t\t\treturn $ns_class;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Add a namespace for which classes may be used without the namespace prefix and\n\t * will be auto-aliased to the global namespace.\n\t * Prefixing the classes will overwrite core classes and previously added namespaces.\n\t *\n\t * @param\tstring\n\t * @param\tbool\n\t * @return\tvoid\n\t */\n\tpublic static function add_core_namespace($namespace, $prefix = true)\n\t{\n\t\tif ($prefix)\n\t\t{\n\t\t\tarray_unshift(static::$core_namespaces, $namespace);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tstatic::$core_namespaces[] = $namespace;\n\t\t}\n\t}\n\n\t/**\n\t * Loads a class.\n\t *\n\t * @param   string  $class  Class to load\n\t * @return  bool    If it loaded the class\n\t */\n\tpublic static function load($class)\n\t{\n\t\t// deal with funny is_callable('static::classname') side-effect\n\t\tif (strpos($class, 'static::') === 0)\n\t\t{\n\t\t\t// is called from within the class, so it's already loaded\n\t\t\treturn true;\n\t\t}\n\n\t\t$loaded = false;\n\t\t$class = ltrim($class, '\\\\');\n\t\t$namespaced = ($pos = strripos($class, '\\\\')) !== false;\n\n\t\tif (empty(static::$auto_initialize))\n\t\t{\n\t\t\tstatic::$auto_initialize = $class;\n\t\t}\n\n\t\tif (isset(static::$classes[$class]))\n\t\t{\n\t\t\tinclude str_replace('/', DS, static::$classes[$class]);\n\t\t\tstatic::init_class($class);\n\t\t\t$loaded = true;\n\t\t}\n\t\telseif ($full_class = static::find_core_class($class))\n\t\t{\n\t\t\tif ( ! class_exists($full_class, false) and ! interface_exists($full_class, false))\n\t\t\t{\n\t\t\t\tinclude static::prep_path(static::$classes[$full_class]);\n\t\t\t}\n\t\t\tclass_alias($full_class, $class);\n\t\t\tstatic::init_class($class);\n\t\t\t$loaded = true;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t$full_ns = substr($class, 0, $pos);\n\n\t\t\tif ($full_ns)\n\t\t\t{\n\t\t\t\tforeach (static::$namespaces as $ns => $path)\n\t\t\t\t{\n\t\t\t\t\t$ns = ltrim($ns, '\\\\');\n\t\t\t\t\tif (stripos($full_ns, $ns) === 0)\n\t\t\t\t\t{\n\t\t\t\t\t\t$path .= static::class_to_path(\n\t\t\t\t\t\t\tsubstr($class, strlen($ns) + 1),\n\t\t\t\t\t\t\tarray_key_exists($ns, static::$psr_namespaces)\n\t\t\t\t\t\t);\n\t\t\t\t\t\tif (is_file($path))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\trequire $path;\n\t\t\t\t\t\t\tstatic::init_class($class);\n\t\t\t\t\t\t\t$loaded = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( ! $loaded)\n\t\t\t{\n\t\t\t\t$path = APPPATH.'classes/'.static::class_to_path($class);\n\n\t\t\t\tif (is_file($path))\n\t\t\t\t{\n\t\t\t\t\tinclude $path;\n\t\t\t\t\tstatic::init_class($class);\n\t\t\t\t\t$loaded = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Prevent failed load from keeping other classes from initializing\n\t\tif (static::$auto_initialize == $class)\n\t\t{\n\t\t\tstatic::$auto_initialize = null;\n\t\t}\n\n\t\treturn $loaded;\n\t}\n\n\t/**\n\t * Reset the auto initialize state after an autoloader exception.\n\t * This method is called by the exception handler, and is considered an\n\t * internal method!\n\t *\n\t * @access protected\n\t */\n\tpublic static function _reset()\n\t{\n\t\tstatic::$auto_initialize = null;\n\t}\n\n\t/**\n\t * Takes a class name and turns it into a path.  It follows the PSR-0\n\t * standard, except for makes the entire path lower case, unless you\n\t * tell it otherwise.\n\t *\n\t * Note: This does not check if the file exists...just gets the path\n\t *\n\t * @param   string  $class  Class name\n\t * @param   bool    $psr    Whether this is a PSR-0 compliant class\n\t * @return  string  Path for the class\n\t */\n\tprotected static function class_to_path($class, $psr = false)\n\t{\n\t\t$file  = '';\n\t\tif ($last_ns_pos = strripos($class, '\\\\'))\n\t\t{\n\t\t\t$namespace = substr($class, 0, $last_ns_pos);\n\t\t\t$class = substr($class, $last_ns_pos + 1);\n\t\t\t$file = str_replace('\\\\', DS, $namespace).DS;\n\t\t}\n\t\t$file .= str_replace('_', DS, $class).'.php';\n\n\t\tif ( ! $psr)\n\t\t{\n\t\t\t$file = strtolower($file);\n\t\t}\n\n\t\treturn $file;\n\t}\n\n\t/**\n\t * Prepares a given path by making sure the directory separators are correct.\n\t *\n\t * @param   string  $path  Path to prepare\n\t * @return  string  Prepped path\n\t */\n\tprotected static function prep_path($path)\n\t{\n\t\treturn str_replace(array('/', '\\\\'), DS, $path);\n\t}\n\n\t/**\n\t * Checks to see if the given class has a static _init() method.  If so then\n\t * it calls it.\n\t *\n\t * @param\tstring\tthe class name\n\t */\n\tprotected static function init_class($class)\n\t{\n\t\tif (static::$auto_initialize === $class)\n\t\t{\n\t\t\tstatic::$auto_initialize = null;\n\t\t\tif (method_exists($class, '_init') and is_callable($class.'::_init'))\n\t\t\t{\n\t\t\t\tcall_user_func($class.'::_init');\n\t\t\t}\n\t\t}\n\t}\n}\n","markers":{"markers":{"1":{"id":1,"range":[[22,16],[22,16]],"tailed":false,"reversed":false,"valid":true,"invalidate":"never","persistent":true,"properties":{"type":"selection","editorId":77,"goalBufferRange":null,"preserveFolds":true},"deserializer":"Marker"}},"deserializer":"MarkerManager"},"history":{"undoStack":[],"redoStack":[],"deserializer":"History"},"filePath":"/Users/kwatanabe/git/whiteplus/hiroie/hiroie_api_develop/api.hiroie.jp/fuel/core/classes/autoloader.php","modifiedWhenLastPersisted":false,"digestWhenLastPersisted":"4d558e87ae6db204400dfca3346c2d74743518ac","deserializer":"TextBuffer"},{"text":"<?php\n/**\n * Part of the Fuel framework.\n *\n * @package    Fuel\n * @version    1.7\n * @author     Fuel Development Team\n * @license    MIT License\n * @copyright  2010 - 2014 Fuel Development Team\n * @link       http://fuelphp.com\n */\n\nnamespace Fuel\\Core;\n\n\n/**\n * View class\n *\n * Acts as an object wrapper for HTML pages with embedded PHP, called \"views\".\n * Variables can be assigned with the view object and referenced locally within\n * the view.\n *\n * @package   Fuel\n * @category  Core\n * @link      http://docs.fuelphp.com/classes/view.html\n */\nclass View\n{\n\n\t/**\n\t * @var  array  Global view data\n\t */\n\tprotected static $global_data = array();\n\n\t/**\n\t * @var  array  Holds a list of specific filter rules for global variables\n\t */\n\tprotected static $global_filter = array();\n\n\t/**\n\t * @var  array  Current active search paths\n\t */\n\tprotected $request_paths = array();\n\n\t/**\n\t * @var  bool  Whether to auto-filter the view's data\n\t */\n\tprotected $auto_filter = true;\n\n\t/**\n\t * @var  array  Holds a list of specific filter rules for local variables\n\t */\n\tprotected $local_filter = array();\n\n\t/**\n\t * @var  string  The view's filename\n\t */\n\tprotected $file_name = null;\n\n\t/**\n\t * @var  array  The view's data\n\t */\n\tprotected $data = array();\n\n\t/**\n\t * @var  string  The view file extension\n\t */\n\tprotected $extension = 'php';\n\n\t/**\n\t * @var  Request  active request when the View was created\n\t */\n\tprotected $active_request = null;\n\n\t/**\n\t * @var  string  active language at the time the object was created\n\t */\n\tprotected $active_language = null;\n\n\t/**\n\t * Returns a new View object. If you do not define the \"file\" parameter,\n\t * you must call [static::set_filename].\n\t *\n\t *     $view = View::forge($file);\n\t *\n\t * @param   string  view filename\n\t * @param   array   array of values\n\t * @return  View\n\t */\n\tpublic static function forge($file = null, $data = null, $auto_filter = null)\n\t{\n\t\treturn new static($file, $data, $auto_filter);\n\t}\n\n\t/**\n\t * Sets the initial view filename and local data.\n\t *\n\t *     $view = new View($file);\n\t *\n\t * @param   string  view filename\n\t * @param   array   array of values\n\t * @return  void\n\t * @uses    View::set_filename\n\t */\n\tpublic function __construct($file = null, $data = null, $filter = null)\n\t{\n\t\tif (is_object($data) === true)\n\t\t{\n\t\t\t$data = get_object_vars($data);\n\t\t}\n\t\telseif ($data and ! is_array($data))\n\t\t{\n\t\t\tthrow new \\InvalidArgumentException('The data parameter only accepts objects and arrays.');\n\t\t}\n\n\t\t$this->auto_filter = is_null($filter) ? \\Config::get('security.auto_filter_output', true) : $filter;\n\n\t\tif ($file !== null)\n\t\t{\n\t\t\t$this->set_filename($file);\n\t\t}\n\n\t\tif ($data !== null)\n\t\t{\n\t\t\t// Add the values to the current data\n\t\t\t$this->data = $data;\n\t\t}\n\n\t\t// store the current request search paths to deal with out-of-context rendering\n\t\tif (class_exists('Request', false) and $active = \\Request::active() and \\Request::main() != $active)\n\t\t{\n\t\t\t$this->request_paths = $active->get_paths();\n\t\t}\n\t\tisset($active) and $this->active_request = $active;\n\n\t\t// store the active language, so we can render the view in the correct language later\n\t\t$this->active_language = \\Config::get('language', 'en');\n\t}\n\n\t/**\n\t * Magic method, searches for the given variable and returns its value.\n\t * Local variables will be returned before global variables.\n\t *\n\t *     $value = $view->foo;\n\t *\n\t * @param   string  variable name\n\t * @return  mixed\n\t * @throws  OutOfBoundsException\n\t */\n\tpublic function & __get($key)\n\t{\n\t\treturn $this->get($key);\n\t}\n\n\t/**\n\t * Magic method, calls [static::set] with the same parameters.\n\t *\n\t *     $view->foo = 'something';\n\t *\n\t * @param   string  variable name\n\t * @param   mixed   value\n\t * @return  void\n\t */\n\tpublic function __set($key, $value)\n\t{\n\t\t$this->set($key, $value);\n\t}\n\n\t/**\n\t * Magic method, determines if a variable is set.\n\t *\n\t *     isset($view->foo);\n\t *\n\t * [!!] `null` variables are not considered to be set by [isset](http://php.net/isset).\n\t *\n\t * @param   string  variable name\n\t * @return  boolean\n\t */\n\tpublic function __isset($key)\n\t{\n\t\treturn (isset($this->data[$key]) or isset(static::$global_data[$key]));\n\t}\n\n\t/**\n\t * Magic method, unsets a given variable.\n\t *\n\t *     unset($view->foo);\n\t *\n\t * @param   string  variable name\n\t * @return  void\n\t */\n\tpublic function __unset($key)\n\t{\n\t\tunset($this->data[$key], static::$global_data[$key]);\n\t}\n\n\t/**\n\t * Magic method, returns the output of [static::render].\n\t *\n\t * @return  string\n\t * @uses    View::render\n\t */\n\tpublic function __toString()\n\t{\n\t\ttry\n\t\t{\n\t\t\treturn $this->render();\n\t\t}\n\t\tcatch (\\Exception $e)\n\t\t{\n\t\t\t\\Error::exception_handler($e);\n\n\t\t\treturn '';\n\t\t}\n\t}\n\n\t/**\n\t * Captures the output that is generated when a view is included.\n\t * The view data will be extracted to make local variables. This method\n\t * is static to prevent object scope resolution.\n\t *\n\t *     $output = $this->process_file();\n\t *\n\t * @param   string  File override\n\t * @param   array   variables\n\t * @return  string\n\t */\n\tprotected function process_file($file_override = false)\n\t{\n\t\t$clean_room = function($__file_name, array $__data)\n\t\t{\n\t\t\textract($__data, EXTR_REFS);\n\n\t\t\t// Capture the view output\n\t\t\tob_start();\n\n\t\t\ttry\n\t\t\t{\n\t\t\t\t// Load the view within the current scope\n\t\t\t\tinclude $__file_name;\n\t\t\t}\n\t\t\tcatch (\\Exception $e)\n\t\t\t{\n\t\t\t\t// Delete the output buffer\n\t\t\t\tob_end_clean();\n\n\t\t\t\t// Re-throw the exception\n\t\t\t\tthrow $e;\n\t\t\t}\n\n\t\t\t// Get the captured output and close the buffer\n\t\t\treturn ob_get_clean();\n\t\t};\n\t\treturn $clean_room($file_override ?: $this->file_name, $this->get_data());\n\t}\n\n\t/**\n\t * Retrieves all the data, both local and global.  It filters the data if\n\t * necessary.\n\t *\n\t *     $data = $this->get_data();\n\t *\n\t * @param   string  $scope  local/glocal/all\n\t * @return  array   view data\n\t */\n\tprotected function get_data($scope = 'all')\n\t{\n\t\t$clean_it = function ($data, $rules, $auto_filter)\n\t\t{\n\t\t\tforeach ($data as $key => &$value)\n\t\t\t{\n\t\t\t\t$filter = array_key_exists($key, $rules) ? $rules[$key] : null;\n\t\t\t\t$filter = is_null($filter) ? $auto_filter : $filter;\n\n\t\t\t\t$value = $filter ? \\Security::clean($value, null, 'security.output_filter') : $value;\n\t\t\t}\n\n\t\t\treturn $data;\n\t\t};\n\n\t\t$data = array();\n\n\t\tif ( ! empty($this->data)  and ($scope === 'all' or $scope === 'local'))\n\t\t{\n\t\t\t$data += $clean_it($this->data, $this->local_filter, $this->auto_filter);\n\t\t}\n\n\t\tif ( ! empty(static::$global_data)  and ($scope === 'all' or $scope === 'global'))\n\t\t{\n\t\t\t$data += $clean_it(static::$global_data, static::$global_filter, $this->auto_filter);\n\t\t}\n\n\t\treturn $data;\n\t}\n\n\t/**\n\t * Sets a global variable, similar to [static::set], except that the\n\t * variable will be accessible to all views.\n\t *\n\t *     View::set_global($name, $value);\n\t *\n\t * @param   string  variable name or an array of variables\n\t * @param   mixed   value\n\t * @param   bool    whether to filter the data or not\n\t * @return  void\n\t */\n\tpublic static function set_global($key, $value = null, $filter = null)\n\t{\n\t\tif (is_array($key))\n\t\t{\n\t\t\tforeach ($key as $name => $value)\n\t\t\t{\n\t\t\t\tif ($filter !== null)\n\t\t\t\t{\n\t\t\t\t\tstatic::$global_filter[$name] = $filter;\n\t\t\t\t}\n\t\t\t\tstatic::$global_data[$name] = $value;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif ($filter !== null)\n\t\t\t{\n\t\t\t\tstatic::$global_filter[$key] = $filter;\n\t\t\t}\n\t\t\tstatic::$global_data[$key] = $value;\n\t\t}\n\t}\n\n\t/**\n\t * Assigns a global variable by reference, similar to [static::bind], except\n\t * that the variable will be accessible to all views.\n\t *\n\t *     View::bind_global($key, $value);\n\t *\n\t * @param   string  variable name\n\t * @param   mixed   referenced variable\n\t * @param   bool    whether to filter the data or not\n\t * @return  void\n\t */\n\tpublic static function bind_global($key, &$value, $filter = null)\n\t{\n\t\tif ($filter !== null)\n\t\t{\n\t\t\tstatic::$global_filter[$key] = $filter;\n\t\t}\n\t\tstatic::$global_data[$key] =& $value;\n\t}\n\n\t/**\n\t * Sets whether to filter the data or not.\n\t *\n\t *     $view->auto_filter(false);\n\t *\n\t * @param   bool  whether to auto filter or not\n\t * @return  View\n\t */\n\tpublic function auto_filter($filter = true)\n\t{\n\t\tif (func_num_args() == 0)\n\t\t{\n\t\t\treturn $this->auto_filter;\n\t\t}\n\n\t\t$this->auto_filter = $filter;\n\n\t\treturn $this;\n\t}\n\n\n\t/**\n\t * Sets the view filename.\n\t *\n\t *     $view->set_filename($file);\n\t *\n\t * @param   string  view filename\n\t * @return  View\n\t * @throws  FuelException\n\t */\n\tpublic function set_filename($file)\n\t{\n\t\t// set find_file's one-time-only search paths\n\t\t\\Finder::instance()->flash($this->request_paths);\n\n\t\t// locate the view file\n\t\tif (($path = \\Finder::search('views', $file, '.'.$this->extension, false, false)) === false)\n\t\t{\n\t\t\tthrow new \\FuelException('The requested view could not be found: '.\\Fuel::clean_path($file));\n\t\t}\n\n\t\t// Store the file path locally\n\t\t$this->file_name = $path;\n\n\t\treturn $this;\n\t}\n\n\t/**\n\t * Searches for the given variable and returns its value.\n\t * Local variables will be returned before global variables.\n\t *\n\t *     $value = $view->get('foo', 'bar');\n\t *\n\t * If the key is not given or null, the entire data array is returned.\n\t *\n\t * If a default parameter is not given and the variable does not\n\t * exist, it will throw an OutOfBoundsException.\n\t *\n\t * @param   string  The variable name\n\t * @param   mixed   The default value to return\n\t * @return  mixed\n\t * @throws  OutOfBoundsException\n\t */\n\tpublic function &get($key = null, $default = null)\n\t{\n\t\tif (func_num_args() === 0 or $key === null)\n\t\t{\n\t\t\treturn $this->data;\n\t\t}\n\t\telseif (array_key_exists($key, $this->data))\n\t\t{\n\t\t\treturn $this->data[$key];\n\t\t}\n\t\telseif (array_key_exists($key, static::$global_data))\n\t\t{\n\t\t\treturn static::$global_data[$key];\n\t\t}\n\n\t\tif (is_null($default) and func_num_args() === 1)\n\t\t{\n\t\t\tthrow new \\OutOfBoundsException('View variable is not set: '.$key);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// assign it first, you can't return a return value by reference directly!\n\t\t\t$default = \\Fuel::value($default);\n\t\t\treturn $default;\n\t\t}\n\t}\n\n\t/**\n\t * Assigns a variable by name. Assigned values will be available as a\n\t * variable within the view file:\n\t *\n\t *     // This value can be accessed as $foo within the view\n\t *     $view->set('foo', 'my value');\n\t *\n\t * You can also use an array to set several values at once:\n\t *\n\t *     // Create the values $food and $beverage in the view\n\t *     $view->set(array('food' => 'bread', 'beverage' => 'water'));\n\t *\n\t * @param   string   variable name or an array of variables\n\t * @param   mixed    value\n\t * @param   bool     whether to filter the data or not\n\t * @return  $this\n\t */\n\tpublic function set($key, $value = null, $filter = null)\n\t{\n\t\tif (is_array($key))\n\t\t{\n\t\t\tforeach ($key as $name => $value)\n\t\t\t{\n\t\t\t\tif ($filter !== null)\n\t\t\t\t{\n\t\t\t\t\t$this->local_filter[$name] = $filter;\n\t\t\t\t}\n\t\t\t\t$this->data[$name] = $value;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif ($filter !== null)\n\t\t\t{\n\t\t\t\t$this->local_filter[$key] = $filter;\n\t\t\t}\n\t\t\t$this->data[$key] = $value;\n\t\t}\n\n\t\treturn $this;\n\t}\n\n\t/**\n\t * The same as set(), except this defaults to not-encoding the variable\n\t * on output.\n\t *\n\t *     $view->set_safe('foo', 'bar');\n\t *\n\t * @param   string   variable name or an array of variables\n\t * @param   mixed    value\n\t * @return  $this\n\t */\n\tpublic function set_safe($key, $value = null)\n\t{\n\t\treturn $this->set($key, $value, false);\n\t}\n\n\t/**\n\t * Assigns a value by reference. The benefit of binding is that values can\n\t * be altered without re-setting them. It is also possible to bind variables\n\t * before they have values. Assigned values will be available as a\n\t * variable within the view file:\n\t *\n\t *     // This reference can be accessed as $ref within the view\n\t *     $view->bind('ref', $bar);\n\t *\n\t * @param   string   variable name\n\t * @param   mixed    referenced variable\n\t * @param   bool     Whether to filter the var on output\n\t * @return  $this\n\t */\n\tpublic function bind($key, &$value, $filter = null)\n\t{\n\t\tif ($filter !== null)\n\t\t{\n\t\t\t$this->local_filter[$key] = $filter;\n\t\t}\n\t\t$this->data[$key] =& $value;\n\n\t\treturn $this;\n\t}\n\n\t/**\n\t * Renders the view object to a string. Global and local data are merged\n\t * and extracted to create local variables within the view file.\n\t *\n\t *     $output = $view->render();\n\t *\n\t * [!!] Global variables with the same key name as local variables will be\n\t * overwritten by the local variable.\n\t *\n\t * @param    string  view filename\n\t * @return   string\n\t * @throws   FuelException\n\t * @uses     static::capture\n\t */\n\tpublic function render($file = null)\n\t{\n\t\t// reactivate the correct request\n\t\tif (class_exists('Request', false))\n\t\t{\n\t\t\t$current_request = \\Request::active();\n\t\t\t\\Request::active($this->active_request);\n\t\t}\n\n\t\t// store the current language, and set the correct render language\n\t\tif ($this->active_language)\n\t\t{\n\t\t\t$current_language = \\Config::get('language', 'en');\n\t\t\t\\Config::set('language', $this->active_language);\n\t\t}\n\n\t\t// override the view filename if needed\n\t\tif ($file !== null)\n\t\t{\n\t\t\t$this->set_filename($file);\n\t\t}\n\n\t\t// and make sure we have one\n\t\tif (empty($this->file_name))\n\t\t{\n\t\t\tthrow new \\FuelException('You must set the file to use within your view before rendering');\n\t\t}\n\n\t\t// combine local and global data and capture the output\n\t\t$return = $this->process_file();\n\n\t\t// restore the current language setting\n\t\t$this->active_language and \\Config::set('language', $current_language);\n\n\t\t// and the active request class\n\t\tif (isset($current_request))\n\t\t{\n\t\t\t\\Request::active($current_request);\n\t\t}\n\n\t\treturn $return;\n\t}\n\n}\n","markers":{"markers":{"1":{"id":1,"range":[[11,0],[11,0]],"tailed":false,"reversed":false,"valid":true,"invalidate":"never","persistent":true,"properties":{"type":"selection","editorId":79,"goalBufferRange":null,"preserveFolds":true},"deserializer":"Marker"}},"deserializer":"MarkerManager"},"history":{"undoStack":[],"redoStack":[],"deserializer":"History"},"filePath":"/Users/kwatanabe/git/whiteplus/hiroie/hiroie_api_develop/api.hiroie.jp/fuel/core/classes/view.php","modifiedWhenLastPersisted":false,"digestWhenLastPersisted":"83f68b7664afb8677239119b3430714f2b852203","deserializer":"TextBuffer"},{"text":"<?php\n/**\n * Part of the Fuel framework.\n *\n * @package    Fuel\n * @version    1.7\n * @author     Fuel Development Team\n * @license    MIT License\n * @copyright  2010 - 2014 Fuel Development Team\n * @link       http://fuelphp.com\n */\n\nnamespace Fuel\\Core;\n\nabstract class Controller\n{\n\n\t/**\n\t * @var  Request  The current Request object\n\t */\n\tpublic $request;\n\n\t/**\n\t * @var  Integer  The default response status\n\t */\n\tpublic $response_status = 200;\n\n\t/**\n\t * Sets the controller request object.\n\t *\n\t * @param   Request   The current request object\n\t */\n\tpublic function __construct(\\Request $request)\n\t{\n\t\t$this->request = $request;\n\t}\n\n\t/**\n\t * This method gets called before the action is called\n\t */\n\tpublic function before() {}\n\n\t/**\n\t * This method gets called after the action is called\n\t */\n\tpublic function after($response)\n\t{\n\t\t// Make sure the $response is a Response object\n\t\tif ( ! $response instanceof Response)\n\t\t{\n\t\t\t$response = \\Response::forge($response, $this->response_status);\n\t\t}\n\n\t\treturn $response;\n\t}\n\n\t/**\n\t * This method returns the named parameter requested, or all of them\n\t * if no parameter is given.\n\t *\n\t * @param   string  $param    The name of the parameter\n\t * @param   mixed   $default  Default value\n\t * @return  mixed\n\t */\n\tpublic function param($param, $default = null)\n\t{\n\t\treturn $this->request->param($param, $default);\n\t}\n\n\t/**\n\t * This method returns all of the named parameters.\n\t *\n\t * @return  array\n\t */\n\tpublic function params()\n\t{\n\t\treturn $this->request->params();\n\t}\n}\n\n","markers":{"markers":{"1":{"id":1,"range":[[48,39],[48,39]],"tailed":false,"reversed":false,"valid":true,"invalidate":"never","persistent":true,"properties":{"type":"selection","editorId":157,"goalBufferRange":null,"preserveFolds":true},"deserializer":"Marker"}},"deserializer":"MarkerManager"},"history":{"undoStack":[],"redoStack":[],"deserializer":"History"},"filePath":"/Users/kwatanabe/git/whiteplus/hiroie/hiroie_api_develop/api.hiroie.jp/fuel/core/classes/controller.php","modifiedWhenLastPersisted":false,"digestWhenLastPersisted":"fcd30fc77b51188f8426b8dd35db660c41a4f99f","deserializer":"TextBuffer"},{"text":"<?php\n/**\n * Part of the Fuel framework.\n *\n * @package    Fuel\n * @version    1.7\n * @author     Fuel Development Team\n * @license    MIT License\n * @copyright  2010 - 2014 Fuel Development Team\n * @link       http://fuelphp.com\n */\n\nnamespace Fuel\\Core;\n\n/**\n * Exception class for standard PHP errors, this will make them catchable\n */\nclass PhpErrorException extends \\ErrorException\n{\n\tpublic static $count = 0;\n\n\t/**\n\t * Allow the error handler from recovering from error types defined in the config\n\t */\n\tpublic function recover()\n\t{\n\t\t// handle the error based on the config and the environment we're in\n\t\tif (static::$count <= Config::get('errors.throttle', 10))\n\t\t{\n\t\t\tlogger(\\Fuel::L_ERROR, $this->code.' - '.$this->message.' in '.$this->file.' on line '.$this->line);\n\n\t\t\tif (\\Fuel::$env != \\Fuel::PRODUCTION and ($this->code & error_reporting()) == $this->code)\n\t\t\t{\n\t\t\t\tstatic::$count++;\n\t\t\t\t\\Error::show_php_error(new \\ErrorException($this->message, $this->code, 0, $this->file, $this->line));\n\t\t\t}\n\t\t}\n\t\telseif (\\Fuel::$env != \\Fuel::PRODUCTION\n\t\t\t\tand static::$count == (\\Config::get('errors.throttle', 10) + 1)\n\t\t\t\tand ($this->severity & error_reporting()) == $this->severity)\n\t\t{\n\t\t\tstatic::$count++;\n\t\t\t\\Error::notice('Error throttling threshold was reached, no more full error reports are shown.', true);\n\t\t}\n\t}\n}\n\n/**\n *\n */\nclass Error\n{\n\n\tpublic static $levels = array(\n\t\t0                   => 'Error',\n\t\tE_ERROR             => 'Fatal Error',\n\t\tE_WARNING           => 'Warning',\n\t\tE_PARSE             => 'Parsing Error',\n\t\tE_NOTICE            => 'Notice',\n\t\tE_CORE_ERROR        => 'Core Error',\n\t\tE_CORE_WARNING      => 'Core Warning',\n\t\tE_COMPILE_ERROR     => 'Compile Error',\n\t\tE_COMPILE_WARNING   => 'Compile Warning',\n\t\tE_USER_ERROR        => 'User Error',\n\t\tE_USER_WARNING      => 'User Warning',\n\t\tE_USER_NOTICE       => 'User Notice',\n\t\tE_STRICT            => 'Runtime Notice',\n\t\tE_RECOVERABLE_ERROR => 'Runtime Recoverable error',\n\t\tE_DEPRECATED        => 'Runtime Deprecated code usage',\n\t\tE_USER_DEPRECATED   => 'User Deprecated code usage',\n\t);\n\n\tpublic static $fatal_levels = array(E_PARSE, E_ERROR, E_USER_ERROR, E_COMPILE_ERROR);\n\n\tpublic static $non_fatal_cache = array();\n\n\t/**\n\t * Native PHP shutdown handler\n\t *\n\t * @return  string\n\t */\n\tpublic static function shutdown_handler()\n\t{\n\t\t$last_error = error_get_last();\n\n\t\t// Only show valid fatal errors\n\t\tif ($last_error AND in_array($last_error['type'], static::$fatal_levels))\n\t\t{\n\t\t\t$severity = static::$levels[$last_error['type']];\n\t\t\tlogger(\\Fuel::L_ERROR, $severity.' - '.$last_error['message'].' in '.$last_error['file'].' on line '.$last_error['line']);\n\n\t\t\t$error = new \\ErrorException($last_error['message'], $last_error['type'], 0, $last_error['file'], $last_error['line']);\n\t\t\tif (\\Fuel::$env != \\Fuel::PRODUCTION)\n\t\t\t{\n\t\t\t\tstatic::show_php_error($error);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tstatic::show_production_error($error);\n\t\t\t}\n\n\t\t\texit(1);\n\t\t}\n\t}\n\n\t/**\n\t * PHP Exception handler\n\t *\n\t * @param   Exception  $e  the exception\n\t * @return  bool\n\t */\n\tpublic static function exception_handler(\\Exception $e)\n\t{\n\t\tif (method_exists($e, 'handle'))\n\t\t{\n\t\t\treturn $e->handle();\n\t\t}\n\n\t\t$severity = ( ! isset(static::$levels[$e->getCode()])) ? $e->getCode() : static::$levels[$e->getCode()];\n\t\tlogger(\\Fuel::L_ERROR, $severity.' - '.$e->getMessage().' in '.$e->getFile().' on line '.$e->getLine());\n\n\t\tif (\\Fuel::$env != \\Fuel::PRODUCTION)\n\t\t{\n\t\t\tstatic::show_php_error($e);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tstatic::show_production_error($e);\n\t\t}\n\t}\n\n\t/**\n\t * PHP Error handler\n\t *\n\t * @param   int     $severity  the severity code\n\t * @param   string  $message   the error message\n\t * @param   string  $filepath  the path to the file throwing the error\n\t * @param   int     $line      the line number of the error\n\t * @return  bool    whether to continue with execution\n\t */\n\tpublic static function error_handler($severity, $message, $filepath, $line)\n\t{\n\t\t// don't do anything if error reporting is disabled\n\t\tif (error_reporting() !== 0)\n\t\t{\n\t\t\t$fatal = (bool)( ! in_array($severity, \\Config::get('errors.continue_on', array())));\n\n\t\t\tif ($fatal)\n\t\t\t{\n\t\t\t\tthrow new \\PhpErrorException($message, $severity, 0, $filepath, $line);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// non-fatal, recover from the error\n\t\t\t\t$e = new \\PhpErrorException($message, $severity, 0, $filepath, $line);\n\t\t\t\t$e->recover();\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Shows an error.  It will stop script execution if the error code is not\n\t * in the errors.continue_on whitelist.\n\t *\n\t * @param   Exception  $e  the exception to show\n\t * @return  void\n\t */\n\tpublic static function show_php_error(\\Exception $e)\n\t{\n\t\t$fatal = (bool)( ! in_array($e->getCode(), \\Config::get('errors.continue_on', array())));\n\t\t$data = static::prepare_exception($e, $fatal);\n\n\t\tif ($fatal)\n\t\t{\n\t\t\t$data['contents'] = ob_get_contents();\n\t\t\twhile (ob_get_level() > 0)\n\t\t\t{\n\t\t\t\tob_end_clean();\n\t\t\t}\n\t\t\tob_start(\\Config::get('ob_callback', null));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tstatic::$non_fatal_cache[] = $data;\n\t\t}\n\n\t\tif (\\Fuel::$is_cli)\n\t\t{\n\t\t\t\\Cli::write(\\Cli::color($data['severity'].' - '.$data['message'].' in '.\\Fuel::clean_path($data['filepath']).' on line '.$data['error_line'], 'red'));\n\t\t\tif (\\Config::get('cli_backtrace'))\n\t\t\t{\n\t\t\t\t\\Cli::write('Stack trace:');\n\t\t\t\t\\Cli::write(\\Debug::backtrace($e->getTrace()));\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tif ($fatal)\n\t\t{\n\t\t\tif ( ! headers_sent())\n\t\t\t{\n\t\t\t\t$protocol = \\Input::server('SERVER_PROTOCOL') ? \\Input::server('SERVER_PROTOCOL') : 'HTTP/1.1';\n\t\t\t\theader($protocol.' 500 Internal Server Error');\n\t\t\t}\n\n\t\t\t$data['non_fatal'] = static::$non_fatal_cache;\n\n\t\t\ttry\n\t\t\t{\n\t\t\t\texit(\\View::forge('errors'.DS.'php_fatal_error', $data, false));\n\t\t\t}\n\t\t\tcatch (\\FuelException $view_exception)\n\t\t\t{\n\t\t\t\texit($data['severity'].' - '.$data['message'].' in '.\\Fuel::clean_path($data['filepath']).' on line '.$data['error_line']);\n\t\t\t}\n\t\t}\n\n\t\ttry\n\t\t{\n\t\t\techo \\View::forge('errors'.DS.'php_error', $data, false);\n\t\t}\n\t\tcatch (\\FuelException $e)\n\t\t{\n\t\t\techo $e->getMessage().'<br />';\n\t\t}\n\t}\n\n\t/**\n\t * Shows a small notice error, only when not in production or when forced.\n\t * This is used by several libraries to notify the developer of certain things.\n\t *\n\t * @param   string  $msg          the message to display\n\t * @param   bool    $always_show  whether to force display the notice or not\n\t * @return  void\n\t */\n\tpublic static function notice($msg, $always_show = false)\n\t{\n\t\t$trace = array_merge(array('file' => '(unknown)', 'line' => '(unknown)'), \\Arr::get(debug_backtrace(), 1));\n\t\tlogger(\\Fuel::L_DEBUG, 'Notice - '.$msg.' in '.$trace['file'].' on line '.$trace['line']);\n\n\t\tif (\\Fuel::$is_test or ( ! $always_show and (\\Fuel::$env == \\Fuel::PRODUCTION or \\Config::get('errors.notices', true) === false)))\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\t$data['message']\t= $msg;\n\t\t$data['type']\t\t= 'Notice';\n\t\t$data['filepath']\t= \\Fuel::clean_path($trace['file']);\n\t\t$data['line']\t\t= $trace['line'];\n\t\t$data['function']\t= $trace['function'];\n\n\t\techo \\View::forge('errors'.DS.'php_short', $data, false);\n\t}\n\n\t/**\n\t * Shows the errors/production view and exits.  This only gets\n\t * called when an error occurs in production mode.\n\t *\n\t * @return  void\n\t */\n\tpublic static function show_production_error(\\Exception $e)\n\t{\n\t\t// when we're on CLI, always show the php error\n\t\tif (\\Fuel::$is_cli)\n\t\t{\n\t\t\treturn static::show_php_error($e);\n\t\t}\n\n\t\tif ( ! headers_sent())\n\t\t{\n\t\t\t$protocol = \\Input::server('SERVER_PROTOCOL') ? \\Input::server('SERVER_PROTOCOL') : 'HTTP/1.1';\n\t\t\theader($protocol.' 500 Internal Server Error');\n\t\t}\n\t\texit(\\View::forge('errors'.DS.'production'));\n\t}\n\n\tprotected static function prepare_exception(\\Exception $e, $fatal = true)\n\t{\n\t\t$data = array();\n\t\t$data['type']\t\t= get_class($e);\n\t\t$data['severity']\t= $e->getCode();\n\t\t$data['message']\t= $e->getMessage();\n\t\t$data['filepath']\t= $e->getFile();\n\t\t$data['error_line']\t= $e->getLine();\n\t\t$data['backtrace']\t= $e->getTrace();\n\n\t\t$data['severity'] = ( ! isset(static::$levels[$data['severity']])) ? $data['severity'] : static::$levels[$data['severity']];\n\n\t\tforeach ($data['backtrace'] as $key => $trace)\n\t\t{\n\t\t\tif ( ! isset($trace['file']))\n\t\t\t{\n\t\t\t\tunset($data['backtrace'][$key]);\n\t\t\t}\n\t\t\telseif ($trace['file'] == COREPATH.'classes/error.php')\n\t\t\t{\n\t\t\t\tunset($data['backtrace'][$key]);\n\t\t\t}\n\t\t}\n\n\t\t$data['debug_lines'] = \\Debug::file_lines($data['filepath'], $data['error_line'], $fatal);\n\t\t$data['orig_filepath'] = $data['filepath'];\n\t\t$data['filepath'] = \\Fuel::clean_path($data['filepath']);\n\n\t\t$data['filepath'] = str_replace(\"\\\\\", \"/\", $data['filepath']);\n\n\t\treturn $data;\n\t}\n\n}\n","markers":{"markers":{"1":{"id":1,"range":[[12,20],[12,20]],"tailed":false,"reversed":false,"valid":true,"invalidate":"never","persistent":true,"properties":{"type":"selection","editorId":235,"goalBufferRange":null,"preserveFolds":true},"deserializer":"Marker"}},"deserializer":"MarkerManager"},"history":{"undoStack":[],"redoStack":[],"deserializer":"History"},"filePath":"/Users/kwatanabe/git/whiteplus/hiroie/hiroie_api_develop/api.hiroie.jp/fuel/core/classes/error.php","modifiedWhenLastPersisted":false,"digestWhenLastPersisted":"ce4f0d00b14b487d2c59df8d98c418a83e67f8b6","deserializer":"TextBuffer"}],"deserializer":"Project"},"workspace":{"paneContainer":{"root":{"items":[{"id":77,"softTabs":true,"scrollTop":0,"scrollLeft":0,"displayBuffer":{"id":78,"softWrap":false,"editorWidthInChars":95,"tokenizedBuffer":{"bufferPath":"/Users/kwatanabe/git/whiteplus/hiroie/hiroie_api_develop/api.hiroie.jp/fuel/core/classes/autoloader.php","tabLength":4,"deserializer":"TokenizedBuffer"},"deserializer":"DisplayBuffer"},"deserializer":"Editor"},{"id":79,"softTabs":true,"scrollTop":0,"scrollLeft":0,"displayBuffer":{"id":80,"softWrap":false,"editorWidthInChars":94,"tokenizedBuffer":{"bufferPath":"/Users/kwatanabe/git/whiteplus/hiroie/hiroie_api_develop/api.hiroie.jp/fuel/core/classes/view.php","tabLength":4,"deserializer":"TokenizedBuffer"},"deserializer":"DisplayBuffer"},"deserializer":"Editor"},{"id":157,"softTabs":true,"scrollTop":138,"scrollLeft":0,"displayBuffer":{"id":158,"softWrap":false,"editorWidthInChars":95,"tokenizedBuffer":{"bufferPath":"/Users/kwatanabe/git/whiteplus/hiroie/hiroie_api_develop/api.hiroie.jp/fuel/core/classes/controller.php","tabLength":4,"deserializer":"TokenizedBuffer"},"deserializer":"DisplayBuffer"},"deserializer":"Editor"},{"id":235,"softTabs":true,"scrollTop":0,"scrollLeft":0,"displayBuffer":{"id":236,"softWrap":false,"editorWidthInChars":98,"tokenizedBuffer":{"bufferPath":"/Users/kwatanabe/git/whiteplus/hiroie/hiroie_api_develop/api.hiroie.jp/fuel/core/classes/error.php","tabLength":4,"deserializer":"TokenizedBuffer"},"deserializer":"DisplayBuffer"},"deserializer":"Editor"}],"activeItemUri":"/Users/kwatanabe/git/whiteplus/hiroie/hiroie_api_develop/api.hiroie.jp/fuel/core/classes/autoloader.php","focused":false,"active":true,"deserializer":"Pane"},"deserializer":"PaneContainer"},"fullScreen":false,"deserializer":"Workspace"},"packageStates":{"fuzzy-finder":{"/Users/kwatanabe/git/whiteplus/hiroie/hiroie_api_develop/api.hiroie.jp/fuel/core/classes/autoloader.php":1396867635549,"/Users/kwatanabe/git/whiteplus/hiroie/hiroie_api_develop/api.hiroie.jp/fuel/core/classes/view.php":1396589560231,"/Users/kwatanabe/git/whiteplus/hiroie/hiroie_api_develop/api.hiroie.jp/fuel/core/classes/controller.php":1396838691476,"/Users/kwatanabe/git/whiteplus/hiroie/hiroie_api_develop/api.hiroie.jp/fuel/core/classes/error.php":1396867634677},"keybinding-resolver":{"attached":false},"metrics":{"sessionLength":1998932},"tree-view":{"directoryExpansionStates":{},"selectedPath":"/Users/kwatanabe/git/whiteplus/hiroie/hiroie_api_develop/api.hiroie.jp/fuel/core/classes/autoloader.php","hasFocus":false,"attached":true,"scrollLeft":8,"scrollTop":0,"width":200}}}